<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="本来不想发的sourcecode, HTML,CSS,JavaScript,JQuery,java,linux">
    <meta name="description" content="若有诗书藏在心，岁月从不败美人">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>本来不想发的sourcecode | 小羊站</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    <!-- 今日诗词特效 -->
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/520ck/cdnseovx/1/I/l/1/I/seovx-com-2d%20%20(73).jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小羊站</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小羊站</div>
        <div class="logo-desc">
            
            若有诗书藏在心，岁月从不败美人
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/wqx8821" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>ERHA
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/wqx8821" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="ERHA" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">本来不想发的sourcecode</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF%E7%88%AC%E6%A5%BC%E6%A2%AF/">
                                <span class="chip bg-color">前端爬楼梯</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-01
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-05-01
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    48 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a name="GCYee"></a></p>
<h1 id="下载准备"><a href="#下载准备" class="headerlink" title="下载准备"></a>下载准备</h1><p><a name="GNqUe"></a></p>
<h2 id="下载-Vue-源码"><a href="#下载-Vue-源码" class="headerlink" title="下载 Vue 源码"></a>下载 Vue 源码</h2><ul>
<li>git 命令</li>
</ul>
<p><code>git&nbsp;clone&nbsp;https://github.com/vuejs/vue.git</code></p>
<p><a name="GZKjn"></a></p>
<h3 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h3><p>执行 npm i 安装依赖<br><a name="qbua4"></a></p>
<h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>在 package.json -&gt; scripts 中的 dev 命令中添加 –sourcemap，这样就可以在浏览器中调试源码时查看当前代码在源码中的位置。<br><code>{&lt;br /&gt;&nbsp;&nbsp;"scripts":&nbsp;{&lt;br /&gt;&nbsp;&nbsp;&nbsp;&nbsp;"dev":&nbsp;"rollup&nbsp;-w&nbsp;-c&nbsp;scripts/config.js&nbsp;--sourcemap&nbsp;--environment&nbsp;TARGET:web-full-dev"&lt;br /&gt;&nbsp;&nbsp;}&lt;br /&gt;}</code><br><a name="rLfKv"></a></p>
<h3 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h3><p>执行以下命令，启动开发环境：<br><code>npm&nbsp;run&nbsp;dev</code></p>
<p>看到如下效果，并在 dist 目录下生成 vue.js.map 文件，则表示成功。到这里所有的准备工作均已完成，但是不要将当前命令行 ctrl + c 掉，因为你在阅读源码时会需要向源码中添加注释，甚至改动源码，当前命令可以监测源码的改动，如果发现改动会自动进行打包；如果关闭当前命令行，你会发现，随着你注释代码的编写，在浏览器中调试源码时会出现和源码映射的偏差。所以为了更好的调试体验就别关闭它。<br><a name="MljwQ"></a></p>
<h2 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h2><p>执行 npm run build 命令之后会发现在 dist 目录下生成一堆特殊命名的 vue.*.js 文件，这些特殊的命名分别是什么意思呢？<br><a name="KE0f0"></a></p>
<h3 id="构建文件分类"><a href="#构建文件分类" class="headerlink" title="构建文件分类"></a>构建文件分类</h3><p>| </p>
<p> | UMD | CommonJS | ES Module |<br>| — | — | — | — |<br>| <strong>Full</strong> | vue.js | vue.common.js | vue.esm.js |<br>| <strong>Runtime-only</strong> | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js |<br>| <strong>Full (production)</strong> | vue.min.js | vue.common.prod.js | </p>
<p> |<br>| <strong>Runtime-only (production)</strong> | vue.runtime.min.js | vue.runtime.common.prod.js | </p>
<p> |</p>
<p><a name="fA6nF"></a></p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><strong>Full</strong>：这是一个全量的包，包含编译器（compiler）和运行时（runtime）。</li>
<li><strong>Compiler</strong>：编译器，负责将模版字符串（即你编写的类 html 语法的模版代码）编译为 JavaScript 语法的 render 函数。</li>
<li><strong>Runtime</strong>：负责创建 Vue 实例、渲染函数、patch 虚拟 DOM 等代码，基本上除了编译器之外的代码都属于运行时代码。</li>
<li><strong>UMD</strong>：兼容 CommonJS 和 AMD 规范，通过 CDN 引入的 vue.js 就是 UMD 规范的代码，包含编译器和运行时。</li>
<li><strong>CommonJS</strong>：典型的应用比如 nodeJS，CommonsJS 规范的包是为了给 browserify 和 webpack 1 这样旧的打包器使用的。他们默认的入口文件为 vue.runtime.common.js。</li>
<li><strong>ES Module</strong>：现代 JavaScript 规范，ES Module 规范的包是给像 webpack 2 和 rollup 这样的现代打包器使用的。这些打包器默认使用仅包含运行时的 vue.runtime.esm.js 文件。<br><a name="v3YVt"></a><h3 id="运行时（Runtime）-编译器（Compiler）-vs-只包含运行时（Runtime-only）"><a href="#运行时（Runtime）-编译器（Compiler）-vs-只包含运行时（Runtime-only）" class="headerlink" title="运行时（Runtime）+ 编译器（Compiler） vs. 只包含运行时（Runtime-only）"></a>运行时（Runtime）+ 编译器（Compiler） vs. 只包含运行时（Runtime-only）</h3>如果你需要动态编译模版（比如：将字符串模版传递给 template 选项，或者通过提供一个挂载元素的方式编写 html 模版），你将需要编译器，因此需要一个完整的构建包。<br>当你使用 vue-loader 或者 vueify 时，*.vue 文件中的模版在构建时会被编译为 JavaScript 的渲染函数。因此你不需要包含编译器的全量包，只需使用只包含运行时的包即可。</li>
</ul>
<p><a name="NFqB5"></a></p>
<h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><p>通过目录结构的阅读，对源码有一个大致的了解，知道哪些东西需要去哪看。</p>
<pre class="line-numbers language-javascript"><code class="language-javascript">├── benchmarks                  性能、基准测试
├── dist                        构建打包的输出目录
├── examples                    案例目录
├── flow                        flow 语法的类型声明
├── packages                    一些额外的包，比如：负责服务端渲染的包 vue<span class="token operator">-</span>server<span class="token operator">-</span>renderer、配合 vue<span class="token operator">-</span>loader 使用的的 vue<span class="token operator">-</span>template<span class="token operator">-</span>compiler，还有 weex 相关的
│   ├── vue<span class="token operator">-</span>server<span class="token operator">-</span>renderer
│   ├── vue<span class="token operator">-</span>template<span class="token operator">-</span>compiler
│   ├── weex<span class="token operator">-</span>template<span class="token operator">-</span>compiler
│   └── weex<span class="token operator">-</span>vue<span class="token operator">-</span>framework
├── scripts                     所有的配置文件的存放位置，比如 rollup 的配置文件
├── src                         vue 源码目录
│   ├── compiler                编译器
│   ├── core                    运行时的核心包
│   │   ├── components          全局组件，比如 keep<span class="token operator">-</span>alive
│   │   ├── config<span class="token punctuation">.</span>js           一些默认配置项
│   │   ├── global<span class="token operator">-</span>api          全局 API，比如熟悉的：Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 等
│   │   ├── instance            Vue 实例相关的，比如 Vue 构造函数就在这个目录下
│   │   ├── observer            响应式原理
│   │   ├── util                工具方法
│   │   └── vdom                虚拟 DOM 相关，比如熟悉的 patch 算法就在这儿
│   ├── platforms               平台相关的编译器代码
│   │   ├── web
│   │   └── weex
│   ├── server                  服务端渲染相关
├── test                        测试目录
├── types                       TS 类型声明
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="aRd1B"></a></p>
<h1 id="Vue初始化过程"><a href="#Vue初始化过程" class="headerlink" title="Vue初始化过程"></a>Vue初始化过程</h1><p><a name="tBk57"></a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Vue 的初始化过程（new Vue(options)）都做了什么？</p>
<ul>
<li>处理组件配置项<ul>
<li>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</li>
<li>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</li>
</ul>
</li>
<li>初始化组件实例的关系属性，比如 children、refs 等</li>
<li>处理自定义事件</li>
<li>调用 beforeCreate 钩子函数</li>
<li>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上</li>
<li>数据响应式，处理 props、methods、data、computed、watch 等选项</li>
<li>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</li>
<li>调用 created 钩子函数</li>
<li>如果发现配置项上有 el 选项，则自动调用 mount 方法，反之，没提供 el 选项则必须调用 $mount</li>
<li>接下来则进入挂载阶段</li>
</ul>
<p><a name="wqacf"></a></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>打断点找寻入口:<code> /src/core/instance/index.js</code><br><a name="sJTfo"></a></p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> initMixin <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./init'</span>

<span class="token comment" spellcheck="true">// Vue 构造函数</span>
<span class="token keyword">function</span> Vue <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 定义 Vue.prototype._init 方法</span>
<span class="token function">initMixin</span><span class="token punctuation">(</span>Vue<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Vue
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="RCWiQ"></a></p>
<h3 id="Vue-prototype-init"><a href="#Vue-prototype-init" class="headerlink" title="Vue.prototype._init"></a>Vue.prototype._init</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">**</span>
 <span class="token operator">*</span> 定义 Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_init 方法 
 <span class="token operator">*</span> @param <span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">}</span> Vue Vue 构造函数
 <span class="token operator">*</span><span class="token operator">/</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> initMixin <span class="token punctuation">(</span>Vue<span class="token punctuation">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 负责 Vue 的初始化过程</span>
  Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_init <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>options<span class="token operator">?</span><span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// vue 实例</span>
    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment" spellcheck="true">// 每个 vue 实例都有一个 _uid，并且是依次递增的</span>
    vm<span class="token punctuation">.</span>_uid <span class="token operator">=</span> uid<span class="token operator">++</span>

    <span class="token comment" spellcheck="true">// a flag to avoid this being observed</span>
    vm<span class="token punctuation">.</span>_isVue <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment" spellcheck="true">// 处理组件配置项</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/**
       * 每个子组件初始化时走这里，这里只做了一些性能优化
       * 将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率
       */</span>
      <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/**
       * 初始化根组件时走这里，合并 Vue 的全局配置到根组件的局部配置，比如 Vue.component 注册的全局组件会合并到 根实例的 components 选项中
       * 至于每个子组件的选项合并则发生在两个地方：
       *   1、Vue.component 方法注册的全局组件在注册时做了选项合并
       *   2、{ components: { xx } } 方式注册的局部组件在执行编译器生成的 render 函数时做了选项合并，包括根组件中的 components 配置
       */</span>
      vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
        <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
        options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/* istanbul ignore else */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 设置代理，将 vm 实例上的属性代理到 vm._renderProxy</span>
      <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// expose real self</span>
    vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm
    <span class="token comment" spellcheck="true">// 初始化组件实例关系属性，比如 $parent、$children、$root、$refs 等</span>
    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">/**
     * 初始化自定义事件，这里需要注意一点，所以我们在 &lt;comp @click="handleClick" /> 上注册的事件，监听者不是父组件，
     * 而是子组件本身，也就是说事件的派发和监听者都是子组件本身，和父组件无关
     */</span>
    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 解析组件的插槽信息，得到 vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 调用 beforeCreate 钩子函数</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 初始化组件的 inject 配置项，得到 result[key] = val 形式的配置对象，然后对结果数据进行响应式处理，并代理每个 key 到 vm 实例</span>
    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve injections before data/props</span>
    <span class="token comment" spellcheck="true">// 数据响应式的重点，处理 props、methods、data、computed、watch</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve provide after data/props</span>
    <span class="token comment" spellcheck="true">// 调用 created 钩子函数</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount，反之，没有 el 则必须手动调用 $mount</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 调用 $mount 方法，进入挂载阶段</span>
      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="OeOWS"></a></p>
<h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><p>-<em>从组件构造函数中解析配置对象 options，并合并基类选项</em><br>resolveConstructorOptions —- &gt;  /src/core/instance/init.js<br><em>-解析构造函数选项中后续被修改或者增加的选项</em><br>resolveModifiedOptions —- &gt;  /src/core/instance/init.js<br>-<em>合并两个选项，出现相同配置项时，子选项会覆盖父选项的配置</em><br>mergeOptions —- &gt; /src/core/util/options.js<br><a name="s1L8R"></a></p>
<h3 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h3><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">// 核心</span>
    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//初始化组件实例的关系属性，比如children refs 等</span>
    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 处理自定义事件</span>
    <span class="token comment" spellcheck="true">// 初始化插槽， 获取this.$slots, 定义this._c ,即cerateElement 平时使用的 h函数</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用 beforeCreate 钩子函数</span>
    <span class="token comment" spellcheck="true">//初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上</span>
    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// resolve injections before data/props</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//数据响应式，处理 props、methods、data、computed、watch 等选项</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//调用 created 钩子函数</span>

    <span class="token comment" spellcheck="true">// 自己没有主动挂载el Vue会自动帮我们挂载会自动挂载（配置项中有el时，没有时需要手动挂载）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="gAOfd"></a></p>
<h1 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h1><p>响应式数据更新的整个执行过程就是：</p>
<ul>
<li>响应式拦截到数据的更新</li>
<li>dep 通知 watcher 进行异步更新</li>
<li>watcher 更新时执行组件更新函数 updateComponent</li>
<li>首先执行 vm._render 生成组件的 vnode，这时就会执行编译器生成的函数<br><a name="sq1am"></a><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2></li>
</ul>
<p><strong>面试官 问</strong>：Vue 响应式原理是怎么实现的？<br><strong>答</strong>：</p>
<ul>
<li>响应式的核心是通过 Object.defineProperty 拦截对数据的访问和设置</li>
<li>响应式的数据分为两类：<ul>
<li>添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新</li>
<li>删除数据时，也要由 dep 通知 watcher 去更新</li>
<li>访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher</li>
<li>设置数据时由 dep 通知相关的 watcher 去更新</li>
<li>对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter</li>
<li>数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作</li>
</ul>
</li>
</ul>
<p><strong>面试官 问</strong>：methods、computed 和 watch 有什么区别？<br><strong>面试官 问：</strong> props与methods优先级<br><strong>面试官 问：</strong> computed缓存的原理<br><a name="Zcfwy"></a></p>
<h2 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h2><p>入口——/src/core/instance/state.js<br><a name="anDcu"></a></p>
<h3 id="核心内容-1"><a href="#核心内容-1" class="headerlink" title="核心内容"></a>核心内容</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> initState <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment" spellcheck="true">// 获取到配置项 分别对props methods data component watch进行初始化</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token comment" spellcheck="true">// 变为响应式 代理props到vue是实例上（能使用this.proKey访问）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 不能体育props key相同 挂载到Vue （能使用this. ）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 判重 不能与methods props 中属性重复</span>
  <span class="token comment" spellcheck="true">// 对数据进行代理 代理到Vue实例上 可以this。  访问</span>
  <span class="token comment" spellcheck="true">// 将数据变为响应式</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">/* asRootData */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">/*
    1. 判重 key不能与，methods props data 属性相同
    2. computed是通过watch来实现的， 对每一个computedkey实例化一个watch， 默认为懒执行
    3. 将computedKey代理到Vue实例上， 支持 this访问
    4. computed具有缓存 是通过 实现
    if (watcher.dirty) {
      // 一次渲染当中 只执行一次computed函数，后续访问不会执行（除非发生更新）
      // 原理 执行watcher.evaluate() 会把watcher.dirty变为 false，只有在update时才会再次变为true
      watcher.evaluate()
    }
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">/**
   * 三件事：
   *   1、处理 watch 对象
   *   2、为 每个 watch.key 创建 watcher 实例，key 和 watcher 实例可能是 一对多 的关系
   *   3、如果设置了 immediate，则立即执行 回调函数
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">/**
   * 其实到这里也能看出，computed 和 watch 在本质是没有区别的，都是通过 watcher 去实现的响应式
   * 非要说有区别，那也只是在使用方式上的区别，简单来说：
   *   1、watch：适用于当数据变化时执行异步或者开销较大的操作时使用，即需要长时间等待的操作可以放在 watch 中
   *   2、computed：其中可以使用异步方法，但是没有任何意义。所以 computed 更适合做一些同步计算
   */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="TPr3R"></a></p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> computedWatcherOptions <span class="token operator">=</span> <span class="token punctuation">{</span> lazy<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 懒执行</span>

<span class="token keyword">function</span> initComputed <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> computed<span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// $flow-disable-line</span>
  <span class="token keyword">const</span> watchers <span class="token operator">=</span> vm<span class="token punctuation">.</span>_computedWatchers <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// computed properties are just getters during SSR</span>
  <span class="token keyword">const</span> isSSR <span class="token operator">=</span> <span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> userDef <span class="token operator">=</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">const</span> getter <span class="token operator">=</span> <span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> userDef <span class="token punctuation">:</span> userDef<span class="token punctuation">.</span><span class="token keyword">get</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> getter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`Getter is missing for computed property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">".`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSSR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 实例化一个 Watcher ，computed原理就是通过 watcher实现</span>
      watchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
        vm<span class="token punctuation">,</span>
        getter <span class="token operator">||</span> noop<span class="token punctuation">,</span>
        noop<span class="token punctuation">,</span>
        computedWatcherOptions <span class="token comment" spellcheck="true">// 默认为懒执行</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> userDef<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The computed property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" is already defined in data.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The computed property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" is already defined as a prop.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods <span class="token operator">&amp;&amp;</span> key <span class="token keyword">in</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The computed property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" is already defined as a method.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> defineComputed <span class="token punctuation">(</span>
  target<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  userDef<span class="token punctuation">:</span> Object <span class="token operator">|</span> Function
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 缓存</span>
  <span class="token keyword">const</span> shouldCache <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> userDef <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 有缓存 就走createComputedGetter(key) 获取数据</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">get</span> <span class="token operator">=</span> shouldCache
      <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">)</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">set</span> <span class="token operator">=</span> noop
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">get</span> <span class="token operator">=</span> userDef<span class="token punctuation">.</span><span class="token keyword">get</span>
      <span class="token operator">?</span> shouldCache <span class="token operator">&amp;&amp;</span> userDef<span class="token punctuation">.</span>cache <span class="token operator">!==</span> <span class="token boolean">false</span>
        <span class="token operator">?</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>userDef<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">)</span>
      <span class="token punctuation">:</span> noop
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">set</span> <span class="token operator">=</span> userDef<span class="token punctuation">.</span><span class="token keyword">set</span> <span class="token operator">||</span> noop
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
      sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">set</span> <span class="token operator">===</span> noop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`Computed property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" was assigned to but it has no setter.`</span></span><span class="token punctuation">,</span>
        <span class="token keyword">this</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 将computed key代理到 vue实例 实现响应式</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> createComputedGetter <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> computedGetter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 计算属性具有缓存的原因（开关阀）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 一次渲染当中 只执行一次computed函数，后续访问不会执行（除非发生更新）</span>
        <span class="token comment" spellcheck="true">// 原理 执行watcher.evaluate() 会把watcher.dirty变为 false，只有在update时才会再次变为true</span>
        watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createGetterInvoker</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> computedGetter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="Or0Xq"></a></p>
<h3 id="响应式入口函数observer"><a href="#响应式入口函数observer" class="headerlink" title="响应式入口函数observer"></a>响应式入口函数observer</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> observe <span class="token punctuation">(</span>value<span class="token punctuation">:</span> any<span class="token punctuation">,</span> asRootData<span class="token punctuation">:</span> <span class="token operator">?</span>boolean<span class="token punctuation">)</span><span class="token punctuation">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> value <span class="token keyword">instanceof</span> <span class="token class-name">VNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> ob<span class="token punctuation">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span>
  <span class="token comment" spellcheck="true">// 若已经是响应式据直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>__ob__ <span class="token keyword">instanceof</span> <span class="token class-name">Observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> value<span class="token punctuation">.</span>__ob__
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
    shouldObserve <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 实例化observer 进行响应式处理</span>
    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>asRootData <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob<span class="token punctuation">.</span>vmCount<span class="token operator">++</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ob
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对象循环使用defineProperty添加响应式，<br>–get中通过dep收集依赖（在dep中存储watcher）<br>–set时通过dep通知相关的watcher更新<br>数组重写数组的七个方法<br>– 添加数据时进行响应式处理，dep通知watcher更新<br>– 删除时也通知进行更新<br><a name="fmKsg"></a></p>
<h1 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h1><p><a name="railC"></a></p>
<h2 id="没听太懂-后续要重新学习"><a href="#没听太懂-后续要重新学习" class="headerlink" title="没听太懂, 后续要重新学习"></a>没听太懂, 后续要重新学习</h2><p><a name="oEe48"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>面试官 问</strong>：Vue 的异步更新机制是如何实现的？<br><strong>答</strong>：<br>Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。<br>当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。<br>然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。<br>如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。<br>flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。<br>flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。<br><strong>面试关 问</strong>：Vue 的 nextTick API 是如何实现的？<br><strong>答</strong>：<br>Vue.nextTick 或者 vm.$nextTick 的原理其实很简单，就做了两件事：</p>
<ul>
<li>将传递的回调函数用 try catch 包裹然后放入 callbacks 数组</li>
<li>执行 timerFunc 函数，在浏览器的异步任务队列放入一个刷新 callbacks 数组的函数<br><a name="W1zrk"></a><h2 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h2><a name="DLF38"></a><h3 id="nexttick部分"><a href="#nexttick部分" class="headerlink" title="nexttick部分"></a>nexttick部分</h3><a name="WjHyz"></a><h4 id="dep-notify-异步更新入口"><a href="#dep-notify-异步更新入口" class="headerlink" title="dep.notify 异步更新入口"></a>dep.notify 异步更新入口</h4>/src/core/observer/dep.js<br>```javascript<br>/**</li>
</ul>
<ul>
<li>通知 dep 中的所有 watcher，执行 watcher.update() 方法</li>
<li>/<br>notify () {<br>// stabilize the subscriber list first<br>const subs = this.subs.slice()<br>// 遍历 dep 中存储的 watcher，执行 watcher.update()<br>for (let i = 0, l = subs.length; i &lt; l; i++) {<br>  subs[i].update()<br>}<br>}<br>```<br><a name="IZNfS"></a><h4 id="watcher-update-观察者更新"><a href="#watcher-update-观察者更新" class="headerlink" title="watcher.update  观察者更新"></a>watcher.update  观察者更新</h4>/src/core/observer/watcher.js<br>计算属性的缓存特性 开关也在这里<br>```javascript<br>/**</li>
<li>根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher</li>
<li>/<br>update () {<br>/* istanbul ignore else */<br>if (this.lazy) {<br>  // 懒执行时走这里，比如 computed<br>  // 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果<br>  this.dirty = true<br>} else if (this.sync) {<br>  // 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项，<br>  // 当为 true 时在数据更新时该 watcher 就不走异步更新队列，直接执行 this.run<br>  // 方法进行更新<br>  // 这个属性在官方文档中没有出现<br>  this.run()<br>} else {<br>  // 更新时一般都这里，将 watcher 放入 watcher 队列<br>  queueWatcher(this)<br>}<br>}<br>```<br><a name="uD5lf"></a><h4 id="queueWatcher-观察者入队-src-core-observer-scheduler-js"><a href="#queueWatcher-观察者入队-src-core-observer-scheduler-js" class="headerlink" title="queueWatcher 观察者入队/src/core/observer/scheduler.js"></a>queueWatcher 观察者入队<br>/src/core/observer/scheduler.js</h4></li>
</ul>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/**

●  将 watcher 放入 watcher 队列
*/</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> queueWatcher <span class="token punctuation">(</span>watcher<span class="token punctuation">:</span> Watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id
    <span class="token comment" spellcheck="true">// 如果 watcher 已经存在，则跳过，不会重复入队</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 缓存 watcher.id，用于判断 watcher 是否已经入队</span>
        has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 当前没有处于刷新队列状态，watcher 直接入队</span>
            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 已经在刷新队列了</span>
            <span class="token comment" spellcheck="true">// 从队列末尾开始倒序遍历，根据当前 watcher.id 找到它大于的 watcher.id 的位置，然后将自己插入到该位置之后的下一个位置</span>
            <span class="token comment" spellcheck="true">// 即将当前 watcher 放入已排序的队列中，且队列仍是有序的</span>
            <span class="token keyword">let</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> index <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id <span class="token operator">></span> watcher<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                i<span class="token operator">--</span>
            <span class="token punctuation">}</span>
            queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> watcher<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// queue the flush</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>waiting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            waiting <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token keyword">async</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 直接刷新调度队列</span>
                <span class="token comment" spellcheck="true">// 一般不会走这儿，Vue 默认是异步执行，如果改为同步执行，性能会大打折扣</span>
                <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">/**
            * 熟悉的 nextTick => vm.$nextTick、Vue.nextTick
            *   1、将 回调函数（flushSchedulerQueue） 放入 callbacks 数组
            *   2、通过 pending 控制向浏览器任务队列中添加 flushCallbacks 函数
            */</span>
            <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="fLloX"></a></p>
<h4 id="nextTick-实现nexttick-src-core-util-next-tick-js"><a href="#nextTick-实现nexttick-src-core-util-next-tick-js" class="headerlink" title="nextTick  实现nexttick/src/core/util/next-tick.js"></a>nextTick  实现nexttick<br>/src/core/util/next-tick.js</h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment" spellcheck="true">/**

● 完成两件事：
● 1、用 try catch 包装 flushSchedulerQueue 函数，然后将其放入 callbacks 数组
● 2、如果 pending 为 false，表示现在浏览器的任务队列中没有 flushCallbacks 函数
●  
如果 pending 为 true，则表示浏览器的任务队列中已经被放入了 flushCallbacks 函数，

●  
待执行 flushCallbacks 函数时，pending 会被再次置为 false，表示下一个 flushCallbacks 函数可以进入

●  
浏览器的任务队列了

● pending 的作用：保证在同一时刻，浏览器的任务队列中只有一个 flushCallbacks 函数
● @param  {*} cb 接收一个回调函数 => flushSchedulerQueue 
● @param  {*} ctx 上下文 
● @returns  
*/</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> nextTick <span class="token punctuation">(</span>cb<span class="token operator">?</span><span class="token punctuation">:</span> Function<span class="token punctuation">,</span> ctx<span class="token operator">?</span><span class="token punctuation">:</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _resolve
    <span class="token comment" spellcheck="true">// 用 callbacks 数组存储经过包装的 cb 函数</span>
    callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 用 try catch 包装回调函数，便于错误捕获</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">'nextTick'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pending <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment" spellcheck="true">// 执行 timerFunc，在浏览器的任务队列中（首选微任务队列）放入 flushCallbacks 函数</span>
        <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// $flow-disable-line</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            _resolve <span class="token operator">=</span> resolve
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>timerFunc 异步策略<br>/src/core/util/next-tick.js</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 可以看到 timerFunc 的作用很简单，就是将 flushCallbacks 函数放入浏览器的异步任务队列中</span>
<span class="token keyword">let</span> timerFunc
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Promise<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 首选 Promise.resolve().then()</span>
    timerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在 微任务队列 中放入 flushCallbacks 函数</span>
        p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">/**
        * 在有问题的UIWebViews中，Promise.then不会完全中断，但是它可能会陷入怪异的状态，
        * 在这种状态下，回调被推入微任务队列，但队列没有被刷新，直到浏览器需要执行其他工作，例如处理一个计时器。
        * 因此，我们可以通过添加空计时器来“强制”刷新微任务队列。
        */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> MutationObserver <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
    <span class="token function">isNative</span><span class="token punctuation">(</span>MutationObserver<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token comment" spellcheck="true">// PhantomJS and iOS 7.x</span>
    MutationObserver<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MutationObserverConstructor]'</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// MutationObserver 次之</span>
    <span class="token comment" spellcheck="true">// Use MutationObserver where native Promise is not available,</span>
    <span class="token comment" spellcheck="true">// e.g. PhantomJS, iOS7, Android 4.4</span>
    <span class="token comment" spellcheck="true">// (#6466 MutationObserver is unreliable in IE11)</span>
    <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span>
    observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        characterData<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    timerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span>
        textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 再就是 setImmediate，它其实已经是一个宏任务了，但仍然比 setTimeout 要好</span>
    timerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 最后没办法，则使用 setTimeout</span>
    timerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a name="LlmHW"></a></p>
<h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><p><a name="B399G"></a></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>面试官 问</strong>：Vue.use(plugin) 做了什么？<strong>答</strong>：负责安装 plugin 插件，其实就是执行插件提供的 install 方法。<ul>
<li>首先判断该插件是否已经安装过</li>
<li>如果没有，则执行插件提供的 install 方法安装插件，具体做什么有插件自己决定</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.mixin(options) 做了什么？<strong>答</strong>：负责在 Vue 的全局配置上合并 options 配置。然后在每个组件生成 vnode 时会将全局配置合并到组件自身的配置上来。<ul>
<li>标准化 options 对象上的 props、inject、directive 选项的格式</li>
<li>处理 options 上的 extends 和 mixins，分别将他们合并到全局配置上</li>
<li>然后将 options 配置和全局配置进行合并，选项冲突时 options 配置会覆盖全局配置</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.component(compName, Comp) 做了什么？<strong>答</strong>：负责注册全局组件。其实就是将组件配置注册到全局配置的 components 选项上（options.components），然后各个子组件在生成 vnode 时会将全局的 components 选项合并到局部的 components 配置项上。<ul>
<li>如果第二个参数为空，则表示获取 compName 的组件构造函数</li>
<li>如果 Comp 是组件配置对象，则使用 Vue.extend 方法得到组件构造函数，否则直接进行下一步</li>
<li>在全局配置上设置组件信息，this.options.components.compName = CompConstructor</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.directive(‘my-directive’, {xx}) 做了什么？<strong>答</strong>：在全局注册 my-directive 指令，然后每个子组件在生成 vnode 时会将全局的 directives 选项合并到局部的 directives 选项中。原理同 Vue.component 方法：<ul>
<li>如果第二个参数为空，则获取指定指令的配置对象</li>
<li>如果不为空，如果第二个参数是一个函数的话，则生成配置对象 { bind: 第二个参数, update: 第二个参数 }</li>
<li>然后将指令配置对象设置到全局配置上，this.options.directives[‘my-directive’] = {xx}</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.filter(‘my-filter’, function(val) {xx}) 做了什么？<strong>答</strong>：负责在全局注册过滤器 my-filter，然后每个子组件在生成 vnode 时会将全局的 filters 选项合并到局部的 filters 选项中。原理是：<ul>
<li>如果没有提供第二个参数，则获取 my-filter 过滤器的回调函数</li>
<li>如果提供了第二个参数，则是设置 this.options.filters[‘my-filter’] = function(val) {xx}。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.extend(options) 做了什么？<strong>答</strong>：Vue.extend 基于 Vue 创建一个子类，参数 options 会作为该子类的默认全局配置，就像 Vue 的默认全局配置一样。所以通过 Vue.extend 扩展一个子类，一大用处就是内置一些公共配置，供子类的子类使用。<ul>
<li>定义子类构造函数，这里和 Vue 一样，也是调用 _init(options)</li>
<li>合并 Vue 的配置和 options，如果选项冲突，则 options 的选项会覆盖 Vue 的配置项</li>
<li>给子类定义全局 API，值为 Vue 的全局 API，比如 Sub.extend = Super.extend，这样子类同样可以扩展出其它子类</li>
<li>返回子类 Sub</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.set(target, key, val) 做了什么<strong>答</strong>：由于 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)，所以通过 Vue.set 为向响应式对象中添加一个 property，可以确保这个新 property 同样是响应式的，且触发视图更新。<ul>
<li>更新数组指定下标的元素：Vue.set(array, idx, val)，内部通过 splice 方法实现响应式更新</li>
<li>更新对象已有属性：Vue.set(obj, key ,val)，直接更新即可 =&gt; obj[key] = val</li>
<li>不能向 Vue 实例或者 $data 动态添加根级别的响应式数据</li>
<li>Vue.set(obj, key, val)，如果 obj 不是响应式对象，会执行 obj[key] = val，但是不会做响应式处理</li>
<li>Vue.set(obj, key, val)，为响应式对象 obj 增加一个新的 key，则通过 defineReactive 方法设置响应式，并触发依赖更新</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.delete(target, key) 做了什么？<strong>答</strong>：删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。当然同样不能删除根级别的响应式属性。<ul>
<li>Vue.delete(array, idx)，删除指定下标的元素，内部是通过 splice 方法实现的</li>
<li>删除响应式对象上的某个属性：Vue.delete(obj, key)，内部是执行 delete obj.key，然后执行依赖更新即可</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：Vue.nextTick(cb) 做了什么？<strong>答</strong>：Vue.nextTick(cb) 方法的作用是延迟回调函数 cb 的执行，一般用于 this.key = newVal 更改数据后，想立即获取更改过后的 DOM 数据：<br>```javascript<br>this.key = ‘new val’</li>
</ul>
<p>Vue.nextTick(function() {<br>  // DOM 更新了<br>})</p>
<pre><code>
- &lt;br /&gt;其内部的执行过程是：
   - this.key = 'new val，触发依赖通知更新，将负责更新的 watcher 放入 watcher 队列
   - 将刷新 watcher 队列的函数放到 callbacks 数组中
   - 在浏览器的异步任务队列中放入一个刷新 callbacks 数组的函数
   - **Vue.nextTick(cb)** 来插队，将 cb 函数放入 callbacks 数组
   - 待将来的某个时刻执行刷新 callbacks 数组的函数
   - 然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM
   - 由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数

&lt;a name="uXhmo"&gt;&lt;/a&gt;
## 源码解析
Vue.set&lt;br /&gt;/src/core/global-api/index.js

```javascript
// /src/core/observer/index.js

/**

● 通过 Vue.set 或者 this.$set 方法给 target 的指定 key 设置值 val
● 如果 target 是对象，并且 key 原本不存在，则为新 key 设置响应式，然后执行依赖通知
*/
export function set (target: Array | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
      (isUndef(target) || isPrimitive(target))
     ) {
    warn(Cannot set reactive property on undefined, null, or primitive value: ${(target: any)})
}
// 更新数组指定下标的元素，Vue.set(array, idx, val)，通过 splice 方法实现响应式更新
if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
  target.length = Math.max(target.length, key)
  target.splice(key, 1, val)
  return val
}
// 更新对象已有属性，Vue.set(obj, key, val)，执行更新即可
if (key in target &amp;&amp; !(key in Object.prototype)) {
  target[key] = val
  return val
}
const ob = (target: any).ob
// 不能向 Vue 实例或者 $data 添加动态添加响应式属性，vmCount 的用处之一，
// this.$data 的 ob.vmCount = 1，表示根组件，其它子组件的 vm.vmCount 都是 0
if (target._isVue || (ob &amp;&amp; ob.vmCount)) {
  process.env.NODE_ENV !== 'production' &amp;&amp; warn(
    'Avoid adding reactive properties to a Vue instance or its root $data ' +
    'at runtime - declare it upfront in the data option.'
  )
  return val
}
// target 不是响应式对象，新属性会被设置，但是不会做响应式处理
if (!ob) {
  target[key] = val
  return val
}
// 给对象定义新属性，通过 defineReactive 方法设置响应式，并触发依赖更新
defineReactive(ob.value, key, val)
ob.dep.notify()
return val
}
</code></pre>
<p><a name="j9ek6"></a></p>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p><a name="kNrGm"></a></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>面试官 问</strong>：vm.$set(obj, key, val) 做了什么？<strong>答</strong>：vm.$set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，比如：this.obj.newProperty = ‘val’、this.arr[3] = ‘val’。所以这才有了 vm.$set，它是 Vue.set 的别名。<ul>
<li>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图</li>
<li>为数组添加一个新的响应式数据：通过 splice 方法实现</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$delete(obj, key)  做了什么？<strong>答</strong>：vm.$delete 用于删除对象上的属性。如果对象是响应式的，且能确保能触发视图更新。该方法主要用于避开 Vue 不能检测属性被删除的情况。它是 Vue.delete 的别名。<ul>
<li>删除数组指定下标的元素，内部通过 splice 方法来完成</li>
<li>删除对象上的指定属性，则是先通过 delete 运算符删除该属性，然后执行 dep.notify 进行依赖通知，更新视图</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$watch(expOrFn, callback, [options]) 做了什么？答：vm.$watch 负责观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。当其发生变化时，回调函数就会被执行，并为回调函数传递两个参数，第一个为更新后的新值，第二个为老值。这里需要 <strong>注意</strong> 一点的是：如果观察的是一个对象，比如：数组，当你用数组方法，比如 push 为数组新增一个元素时，回调函数被触发时传递的新值和老值相同，因为它们指向同一个引用，所以在观察一个对象并且在回调函数中有新老值是否相等的判断时需要注意。vm.$watch 的第一个参数只接收简单的响应式数据的键路径，对于更复杂的表达式建议使用函数作为第一个参数。至于 vm.$watch 的内部原理是：<ul>
<li>设置 options.user = true，标志是一个用户 watcher</li>
<li>实例化一个 Watcher 实例，当检测到数据更新时，通过 watcher 去触发回调函数的执行，并传递新老值作为回调函数的参数</li>
<li>返回一个 unwatch 函数，用于取消观察</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$on(event, callback) 做了什么？<strong>答</strong>：监听当前实例上的自定义事件，事件可由 vm.emit）的额外参数。vm.$on 的原理很简单，就是处理传递的 event 和 callback 两个参数，将注册的事件和回调函数以键值对的形式存储到 vm._event 对象中，vm._events = { eventName: [cb1, cb2, …], … }。</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$emit(eventName, […args]) 做了什么？<strong>答</strong>：触发当前实例上的指定事件，附加参数都会传递给事件的回调函数。其内部原理就是执行 vm._events[eventName] 中所有的回调函数。备注：从 emit 的实现原理也能看出，组件的自定义事件其实是谁触发谁监听，所以在这会儿再回头看 [Vue 源码解读（2）—— Vue <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NTk4NjQ1OQ==&amp;mid=2247484817&amp;idx=1&amp;sn=d6357aed6fd2f7e7cc8e47f8ad79ea96&amp;chksm=9f6966e5a81eeff3eb2ac169a41fba0960e9cc8863c193e8608501a873bead743021d37d71f7#rd">初始化</a> )过程中关于 initEvent </li>
<li>的解释就会明白在说什么，因为组件自定义事件的处理内部用的就是 vm.emit。</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$off([event, callback]) 做了什么？<strong>答</strong>：移除自定义事件监听器，即移除 vm._events 对象上相关数据。<ul>
<li>如果没有提供参数，则移除实例的所有事件监听</li>
<li>如果只提供了 event 参数，则移除实例上该事件的所有监听器</li>
<li>如果两个参数都提供了，则移除实例上该事件对应的监听器</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$once(event, callback)  做了什么？<strong>答</strong>：监听一个自定义事件，但是该事件只会被触发一次。一旦触发以后监听器就会被移除。其内部的实现原理是：<ul>
<li>包装用户传递的回调函数，当包装函数执行的时候，除了会执行用户回调函数之外还会执行 vm.$off(event, 包装函数) 移除该事件</li>
<li>用 vm.$on(event, 包装函数) 注册事件</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm._update(vnode, hydrating)  做了什么？<strong>答</strong>：官方文档没有说明该 API，这是一个用于源码内部的实例方法，负责更新页面，是页面渲染的入口，其内部根据是否存在 prevVnode 来决定是首次渲染，还是页面更新，从而在调用 <strong>patch</strong> 函数时传递不同的参数。该方法在业务开发中不会用到。</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$forceUpdate()  做了什么？<strong>答</strong>：迫使 Vue 实例重新渲染，它仅仅影响组件实例本身和插入插槽内容的子组件，而不是所有子组件。其内部原理到也简单，就是直接调用 vm._watcher.update()，它就是 watcher.update() 方法，执行该方法触发组件更新。</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$destroy()  做了什么？<strong>答</strong>：负责完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令和事件监听器。在执行过程中会调用 beforeDestroy 和 destroy 两个钩子函数。在大多数业务开发场景下用不到该方法，一般都通过 v-if 指令来操作。其内部原理是：<ul>
<li>调用 beforeDestroy 钩子函数</li>
<li>将自己从老爹肚子里（$parent）移除，从而销毁和老爹的关系</li>
<li>通过 watcher.teardown() 来移除依赖监听</li>
<li>通过 vm.<strong>patch</strong>(vnode, null) 方法来销毁节点</li>
<li>调用 destroyed 钩子函数</li>
<li>通过 vm.$off 方法移除所有的事件监听</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官 问</strong>：vm.$nextTick(cb)  做了什么？<strong>答</strong>：vm.$nextTick 是 Vue.nextTick 的别名，其作用是延迟回调函数 cb 的执行，一般用于 this.key = newVal 更改数据后，想立即获取更改过后的 DOM 数据：<br>```javascript<br>this.key = ‘new val’</li>
</ul>
<p>Vue.nextTick(function() {<br>  // DOM 更新了<br>})</p>
<pre><code>
- &lt;br /&gt;其内部的执行过程是：
   - this.key = 'new val'，触发依赖通知更新，将负责更新的 watcher 放入 watcher 队列
   - 将刷新 watcher 队列的函数放到 callbacks 数组中
   - 在浏览器的异步任务队列中放入一个刷新 callbacks 数组的函数
   - **vm.$nextTick(cb)** 来插队，直接将 cb 函数放入 callbacks 数组
   - 待将来的某个时刻执行刷新 callbacks 数组的函数
   - 然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM
   - 由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数

---

- **面试官 问**：vm._render  做了什么？**答**：官方文档没有提供该方法，它是一个用于源码内部的实例方法，负责生成 vnode。其关键代码就一行，执行 render 函数生成 vnode。不过其中加了大量的异常处理代码。

&lt;a name="P9wQm"&gt;&lt;/a&gt;
# 编译原理
编译器解析部分的本质：将类 HTML 字符串模版解析成 AST 对象。
&lt;a name="cfC4D"&gt;&lt;/a&gt;
## 总结

- **面试官 问**：简单说一下 Vue 的编译器都做了什么？**答**：Vue 的编译器做了三件事情：
   - 将组件的 html 模版解析成 AST 对象
   - 优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数
   - 从 AST 生成运行时的渲染函数，即大家说的 render，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数

---

- **面试官 问**：详细说一说编译器的解析过程，它是怎么将 html 字符串模版变成 AST 对象的？**答**：
   - 如果匹配到结束标签，就从 stack 数组中拿出最后一个元素，它和当前匹配到的结束标签是一对。
   - 再次处理开始标签上的属性，这些属性和前面处理的不一样，比如：key、ref、scopedSlot、样式等，并将处理结果放到元素的 AST 对象上**备注** 视频中说这块儿有误，回头看了下，没有问题，不需要改，确实是这样
   - 然后将当前元素和父元素产生联系，给当前元素的 ast 对象设置 parent 属性，然后将自己放到父元素的 ast 对象的 children 数组中
   - 得到一个对象，包括 标签名（tagName）、所有的属性（attrs）、标签在 html 模版字符串中的索引位置
   - 进一步处理上一步得到的 attrs 属性，将其变成 [{ name: attrName, value: attrVal, start: xx, end: xx }, ...] 的形式
   - 通过标签名、属性对象和当前元素的父元素生成 AST 对象，其实就是一个 普通的 JS 对象，通过 key、value 的形式记录了该元素的一些信息
   - 接下来进一步处理开始标签上的一些指令，比如 v-pre、v-for、v-if、v-once，并将处理结果放到 AST 对象上
   - 处理结束将 ast 对象存放到 stack 数组
   - 处理完成后会截断 html 字符串，将已经处理掉的字符串截掉
   - 遍历 HTML 模版字符串，通过正则表达式匹配 "&lt;"
   - 跳过某些不需要处理的标签，比如：注释标签、条件注释标签、Doctype。备注：整个解析过程的核心是处理开始标签和结束标签
   - 解析开始标签
   - 解析闭合标签
   - 最后遍历完整个 html 模版字符串以后，返回 ast 对象
&lt;a name="HlVcu"&gt;&lt;/a&gt;
## 解析（不含源码 太多了）
```javascript
// 转换AST 时 处理的所有内容 记录
const element = {
  type: 1,
  tag,
  attrsList: [{ name: attrName, value: attrVal, start, end }],
  attrsMap: { attrName: attrVal, },
  rawAttrsMap: { attrName: attrVal, type: checkbox },
  // v-if
  ifConditions: [{ exp, block }],
  // v-for
  for: iterator,
  alias: 别名,
  // :key
  key: xx,
  // ref
  ref: xx,
  refInFor: boolean,
  // 插槽
  slotTarget: slotName,
  slotTargetDynamic: boolean,
  slotScope: 作用域插槽的表达式,
  scopeSlot: {
    name: {
      slotTarget: slotName,
      slotTargetDynamic: boolean,
      children: {
        parent: container,
        otherProperty,
      }
    },
    slotScope: 作用域插槽的表达式,
  },
  slotName: xx,
  // 动态组件
  component: compName,
  inlineTemplate: boolean,
  // class
  staticClass: className,
  classBinding: xx,
  // style
  staticStyle: xx,
  styleBinding: xx,
  // attr
  hasBindings: boolean,
  nativeEvents: {同 evetns},
  events: {
    name: [{ value, dynamic, start, end, modifiers }]
  },
  props: [{ name, value, dynamic, start, end }],
  dynamicAttrs: [同 attrs],
  attrs: [{ name, value, dynamic, start, end }],
  directives: [{ name, rawName, value, arg, isDynamicArg, modifiers, start, end }],
  // v-pre
  pre: true,
  // v-once
  once: true,
  parent,
  children: [],
  plain: boolean,
}
</code></pre>
<p><a name="dyh66"></a></p>
<h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><p><a name="PE5pd"></a></p>
<h2 id="总结（标记静态节点，生成渲染函数时忽略-提高性能）"><a href="#总结（标记静态节点，生成渲染函数时忽略-提高性能）" class="headerlink" title="总结（标记静态节点，生成渲染函数时忽略  提高性能）"></a>总结（标记静态节点，生成渲染函数时忽略  提高性能）</h2><ul>
<li><strong>面试官 问</strong>：简单说一下 Vue 的编译器都做了什么？<strong>答</strong>：Vue 的编译器做了三件事情：<ul>
<li>将组件的 html 模版解析成 AST 对象</li>
<li>优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数</li>
<li>从 AST 生成运行渲染函数，即大家说的 render，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官</strong>：详细说一下静态标记的过程<strong>答</strong>：<ul>
<li>如果节点本身是静态节点 &amp;&amp; 而且有子节点 &amp;&amp; 子节点不全是文本节点，则标记为静态根节点</li>
<li>如果节点本身不是静态根节点，则递归的遍历所有子节点，在子节点中标记静态根</li>
<li>通过递归的方式标记所有的元素节点</li>
<li>如果节点本身是静态节点，但是存在非静态的子节点，则将节点修改为非静态节点</li>
<li>标记静态节点</li>
<li>标记静态根节点，基于静态节点，进一步标记静态根节点</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>面试官</strong>：什么样的节点才可以被标记为静态节点？<strong>答</strong>：</p>
<ul>
<li>文本节点</li>
<li>节点上没有 v-bind、v-for、v-if 等指令</li>
<li>非组件<br><a name="VLtn7"></a><h1 id="生成渲染函数"><a href="#生成渲染函数" class="headerlink" title="生成渲染函数"></a>生成渲染函数</h1><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NTk4NjQ1OQ==&amp;mid=2247485160&amp;idx=1&amp;sn=8b2610e04bbdc7e4ee32c87b7849a902&amp;chksm=9f69659ca81eec8aa7849343fe33ab066966527e73ea8b487bd05b29d9efb0c2ecaa1e2cecfd&amp;scene=178&amp;cur_album_id=2273541436891693065#rd">大佬文章</a><br><a name="HfZJC"></a><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2></li>
</ul>
</li>
<li><p><strong>面试官 问</strong>：简单说一下 Vue 的编译器都做了什么？<strong>答</strong>：Vue 的编译器做了三件事情：</p>
<ul>
<li>将组件的 html 模版解析成 AST 对象</li>
<li>优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数</li>
<li>从 AST 生成运行渲染函数，即大家说的 render，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>面试官</strong>：详细说一下渲染函数的生成过程<strong>答</strong>：大家一说到渲染函数，基本上说的就是 render 函数，其实编译器生成的渲染有两类：渲染函数生成的过程，其实就是在遍历 AST 节点，通过递归的方式，处理每个节点，最后生成形如：_c(tag, attr, children, normalizationType) 的结果。tag 是标签名，attr 是属性对象，children 是子节点组成的数组，其中每个元素的格式都是 _c(tag, attr, children, normalizationTYpe) 的形式，normalization 表示节点的规范化类型，是一个数字 0、1、2，不重要。在处理 AST 节点过程中需要大家重点关注也是面试中常见的问题有：<ul>
<li>单纯的 v-once 节点处理方式和静态节点一致</li>
<li>v-if 节点的处理结果是一个三元表达式</li>
<li>v-for 节点的处理结果是可执行的 _l 函数，该函数负责生成 v-for 节点的 vnode</li>
<li>组件的处理结果和普通元素一样，得到的是形如 _c(compName) 的可执行代码，生成组件的 vnode</li>
<li>将生成静态节点 vnode 函数放到 staticRenderFns 数组中</li>
<li>返回一个 _m(idx) 的可执行函数，意思是执行 staticRenderFns 数组中下标为 idx 的函数，生成静态节点的 vnode</li>
<li>静态节点是怎么处理的静态节点的处理分为两步：</li>
<li>v-once、v-if、v-for、组件 等都是怎么处理的</li>
<li>第一类就是一个 render 函数，负责生成动态节点的 vnode</li>
<li>第二类是放在一个叫 staticRenderFns 数组中的静态渲染函数，这些函数负责生成静态节点的 vnode<br><a name="DC9wS"></a><h1 id="rebder-helper"><a href="#rebder-helper" class="headerlink" title="rebder helper"></a>rebder helper</h1></li>
</ul>
</li>
</ul>
<p><strong>面试官 问</strong>：一个组件是如何变成 VNode？<br><strong>答</strong>：</p>
<ul>
<li>组件实例初始化，最后执行 $mount 进入挂载阶段</li>
<li>如果是只包含运行时的 vue.js，只直接进入挂载阶段，因为这时候的组件已经变成了渲染函数，编译过程通过模块打包器 + vue-loader + vue-template-compiler 完成的</li>
<li>如果没有使用预编译，则必须使用全量的 vue.js</li>
<li>挂载时如果发现组件配置项上没有 render 选项，则进入编译阶段</li>
<li>将模版字符串编译成 AST 语法树，其实就是一个普通的 JS 对象</li>
<li>然后优化 AST，遍历 AST 对象，标记每一个节点是否为静态静态；然后再进一步标记出静态根节点，在组件后续更新时会跳过这些静态节点的更新，以提高性能</li>
<li>接下来从 AST 生成渲染函数，生成的渲染函数有两部分组成：<ul>
<li>负责生成动态节点 VNode 的 render 函数</li>
<li>还有一个 staticRenderFns 数组，里面每一个元素都是一个生成静态节点 VNode 的函数，这些函数会作为 render 函数的组成部分，负责生成静态节点的 VNode</li>
</ul>
</li>
<li>接下来将渲染函数放到组件的配置对象上，进入挂载阶段，即执行 mountComponent 方法</li>
<li>最终负责渲染组件和更新组件的是一个叫 updateComponent 方法，该方法每次执行前首先需要执行 vm._render 函数，该函数负责执行编译器生成的 render，得到组件的 VNode</li>
<li>将一个组件生成 VNode 的具体工作是由 render 函数中的 _c、_o、_l、_m 等方法完成的，这些方法都被挂载到 Vue 实例上面，负责在运行时生成组件 VNode</li>
</ul>
<p><strong>提示</strong>：到这里首先要明白什么是 VNode，一句话描述就是 —— 组件模版的 JS 对象表现形式，它就是一个普通的 JS 对象，详细描述了组件中各节点的信息<br>下面说的有点多，其实记住一句就可以了，设置组件配置信息，然后通过 new VNode(组件信息) 生成组件的 VNode</p>
<ul>
<li>_c，负责生成组件或 HTML 元素的 VNode，_c 是所有 render helper 方法中最复杂，也是最核心的一个方法，其它的 _xx 都是它的组成部分<ul>
<li>函数式组件执行自己的 render 函数生成 VNode</li>
<li>普通组件则实例化一个 VNode，并且在在 data.hook 对象上设置 4 个方法，在组件的 patch 阶段会被调用，从而进入子组件的实例化、挂载阶段，然后进行编译生成渲染函数，直至完成渲染</li>
<li>当然生成 VNode 之前会进行一些配置处理比如：</li>
<li>子组件选项合并，合并全局配置项到组件配置项上</li>
<li>处理自定义组件的 v-model</li>
<li>处理组件的 props，提取组件的 props 数据，以组件的 props 配置中的属性为 key，父组件中对应的数据为 value 生成一个 propsData 对象；当组件更新时生成新的 VNode，又会进行这一步，这就是 props 响应式的原理</li>
<li>处理其它数据，比如监听器</li>
<li>安装内置的 init、prepatch、insert、destroy 钩子到 data.hooks 对象上，组件 patch 阶段会用到这些钩子方法</li>
<li>接收标签、属性 JSON 字符串、子节点数组、节点规范化类型作为参数</li>
<li>如果标签是平台保留标签或者一个未知的元素，则直接 new VNode(标签信息) 得到 VNode</li>
<li>如果标签是一个组件，则执行 createComponent 方法生成 VNode</li>
</ul>
</li>
<li>_l，运行时渲染 v-for 列表的帮助函数，循环遍历 val 值，依次为每一项执行 render 方法生成 VNode，最终返回一个 VNode 数组</li>
<li>_m，负责生成静态节点的 VNode，即执行 staticRenderFns 数组中指定下标的函数</li>
</ul>
<p><strong>简单总结 render helper 的作用就是</strong>：在 Vue 实例上挂载一些运行时的工具方法，这些方法用在编译器生成的渲染函数中，用于生成组件的 VNode。<br>好了，到这里，一个组件从初始化开始到最终怎么变成 VNode 就讲完了，最后剩下的就是 patch 阶段了，下一篇文章将讲述如何将组件的 VNode 渲染到页面上。</p>
<p><a name="TC8bM"></a></p>
<h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NTk4NjQ1OQ==&amp;mid=2247485191&amp;idx=1&amp;sn=e0ee8a4bf17a83b4facb397361eaee4f&amp;chksm=9f696473a81eed65d220d09e7c3dc3d5959fe3df5b7c8dba071407168041e09154b76a7d7de1&amp;scene=178&amp;cur_album_id=2273541436891693065#rd">大佬文章</a><br><a name="naWxF"></a></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>面试官 问</strong>：你能说一说 Vue 的 patch 算法吗？<strong>答</strong>：Vue 的 patch 算法有三个作用：负责首次渲染和后续更新或者销毁组件<ul>
<li>首先是全量更新所有的属性</li>
<li>如果新老 VNode 都有孩子，则递归执行 updateChildren，进行 diff 过程针对前端操作 DOM 节点的特点进行如下优化：</li>
<li>如果新的 VNode 有孩子，老的 VNode 没孩子，则新增这些新孩子节点</li>
<li>如果老的 VNode 有孩子，新的 VNode 没孩子，则删除这些老孩子节点</li>
<li>剩下一种就是更新文本节点</li>
<li>同层比较（降低时间复杂度）深度优先（递归）</li>
<li>而且前端很少有完全打乱节点顺序的情况，所以做了四种假设，假设新老 VNode 的开头结尾存在相同节点，一旦命中假设，就避免了一次循环，降低了 diff 的时间复杂度，提高执行效率。如果不幸没有命中假设，则执行遍历，从老的 VNode 中找到新的 VNode 的开始节点</li>
<li>找到相同节点，则执行 patchVnode，然后将老节点移动到正确的位置</li>
<li>如果老的 VNode 先于新的 VNode 遍历结束，则剩余的新的 VNode 执行新增节点操作</li>
<li>如果新的 VNode 先于老的 VNode 遍历结束，则剩余的老的 VNode 执行删除操纵，移除这些老节点</li>
<li>如果老的 VNode 是真实元素，则表示首次渲染，创建整棵 DOM 树，并插入 body，然后移除老的模版节点</li>
<li>如果老的 VNode 不是真实元素，并且新的 VNode 也存在，则表示更新阶段，执行 patchVnode</li>
<li>如果新的 VNode 不存在，老的 VNode 存在，则调用 destroy，销毁老节点</li>
</ul>
</li>
</ul>
<p>本文大部分摘取至 掘金大佬李永宁文章，跟着他的文章学习了很多，留个纪念<br>—— 大佬 <a target="_blank" rel="noopener" href="https://juejin.cn/user/1028798616461326/posts">掘金链接</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ERHA</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/05/01/sourceCode/">http://example.com/2022/05/01/sourceCode/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ERHA</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF%E7%88%AC%E6%A5%BC%E6%A2%AF/">
                                    <span class="chip bg-color">前端爬楼梯</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="google,qq,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/05/03/setup%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8Vuex%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.seovx.com/d/?mom=302" class="responsive-img" alt="setup如何优雅使用Vuex辅助函数">
                        
                        <span class="card-title">setup如何优雅使用Vuex辅助函数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-05-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ERHA
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF%E7%88%AC%E6%A5%BC%E6%A2%AF/">
                        <span class="chip bg-color">前端爬楼梯</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/04/23/vue3%E4%B8%80%E4%BA%9B%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.seovx.com/d/?mom=302" class="responsive-img" alt="vue3一些源码学习">
                        
                        <span class="card-title">vue3一些源码学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-04-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF%E7%88%AC%E6%A5%BC%E6%A2%AF/">
                        <span class="chip bg-color">前端爬楼梯</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 小羊站<br />'
            + '文章作者: ERHA<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2257381805"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <!-- <span id="year">2021</span>
            <a href="/about" target="_blank">ERHA</a>
            |&nbsp;lcywqx&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">1314</a>
            <br> -->
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">88.6k</span>&nbsp;字
            
            
            
            
            
            
            <!-- <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span> -->
            
            
            <!-- <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span> -->
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "9";
                    var startDate = "27";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <!-- <br>
             -->
        </div>
        <!-- <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wqx8821" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:930707472@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=930707472" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 930707472" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div> -->
    </div>
</footer>

<!-- <div class="progress-bar"></div> -->


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>

    <script src="/js/cursor.js"></script>
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
      <!-- 动态标题 -->
    <script type="text/javascript"> var OriginTitile = document.title, st; 
        document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ啊呀！你咋走了", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪哼，还知道回来！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

</body>

</html>
