<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于ts</title>
      <link href="/2021/09/27/%E5%85%B3%E4%BA%8Ets/"/>
      <url>/2021/09/27/%E5%85%B3%E4%BA%8Ets/</url>
      
        <content type="html"><![CDATA[<h1 id="1、TS初见"><a href="#1、TS初见" class="headerlink" title="1、TS初见"></a>1、TS初见</h1><h2 id="1-1、为什么要有-TypeScript"><a href="#1-1、为什么要有-TypeScript" class="headerlink" title="1.1、为什么要有 TypeScript"></a>1.1、为什么要有 TypeScript</h2><p>TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。</p><p>`TypeScript的初衷就是为了做类型检查，提早发现错误，所以「类型」是其最核心的特性。当然它只是给出你代码可能不会按预期执行的警告，比如你未按照声明的类型传参，你的代码还是可以运行的。这一点与强类型语言还是有本质的区别，强类型语言会直接导致编译不通过，因为TypeScript只是转译。跟JavaScript不同，TypeScript文件后缀使用 .ts扩展名。浏览器是不识别 .ts 文件，所以使用时必须提前把 TS 代码转换成 JavaScript 代码。这个转换过程被称为转译，编译和转译的微小差别在于：</p><p>编译是把源码转变成另一种语言<br>转译是把源码转变另一个相同抽象层级的语言</p><h2 id="1-2、前提准备"><a href="#1-2、前提准备" class="headerlink" title="1.2、前提准备"></a>1.2、前提准备</h2><ul><li>安装 node环境下安装 npm install -g typescript</li><li>手动编译 tsc  **.ts</li><li>vscode自动编译 tsc –init 在tsconfig.js中配置，在终端打开tsc监视即可</li><li>ts语法提示错误，不影响js的编译，因为js是弱类型语言（如类型注解不通过）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 类型注解 一种轻量级的为函数或变量添加约束</span><br><span class="line">(() =&gt; {</span><br><span class="line">    function showMsg(str:String) {</span><br><span class="line">        return str + '123214'</span><br><span class="line">    }</span><br><span class="line">    let str = "woshi"</span><br><span class="line">    console.log(showMsg(str));</span><br><span class="line">    </span><br><span class="line">})()</span><br><span class="line"></span><br><span class="line">// 接口演示 定义接口</span><br><span class="line">(() =&gt; {</span><br><span class="line">    interface Iperson{</span><br><span class="line">        fristName:string,</span><br><span class="line">        lastName:string</span><br><span class="line">    }</span><br><span class="line">    // 输出对象</span><br><span class="line">    function showFullName(person:Iperson) {</span><br><span class="line">        return person.fristName + person.lastName</span><br><span class="line">    }</span><br><span class="line">    // 定义对象</span><br><span class="line">    const person = {</span><br><span class="line">        fristName: 'dongfnag',</span><br><span class="line">        lastName: 'yuechu'</span><br><span class="line">    }</span><br><span class="line">    // 打印</span><br><span class="line">    console.log(showFullName(person))</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3、基础类型"><a href="#1-3、基础类型" class="headerlink" title="1.3、基础类型"></a>1.3、基础类型</h2><h3 id="1、布尔-数字-字符串"><a href="#1、布尔-数字-字符串" class="headerlink" title="1、布尔 数字 字符串"></a>1、布尔 数字 字符串</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a:boolean = true</span><br><span class="line">let b:number = 1010</span><br><span class="line">let c:string = '字符串'</span><br><span class="line"></span><br><span class="line">//字符串可与数字拼接 TS中变量一开始是什么类型就只能用这个类型，不允许混用</span><br></pre></td></tr></tbody></table></figure><h3 id="2、undefined-amp-null"><a href="#2、undefined-amp-null" class="headerlink" title="2、undefined &amp; null"></a>2、undefined &amp; null</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let und:undefined = undefined</span><br><span class="line">let nul:null = null</span><br><span class="line">// 给其他类型赋予</span><br><span class="line">let num:number = null</span><br><span class="line">let num:number = undefined</span><br><span class="line"></span><br><span class="line">// undefined和null 可以作为其他类型的子类型，可以将undef和null赋予其他类型（需关闭ts严格模式）</span><br></pre></td></tr></tbody></table></figure><h3 id="3、-数组和元组"><a href="#3、-数组和元组" class="headerlink" title="3、 数组和元组"></a>3、 数组和元组</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组定义方式1</span><br><span class="line">let arr:number[] = [10,20,30]</span><br><span class="line">数组定义方式2(泛型写法)</span><br><span class="line">let arr:Array&lt;number&gt; = [1,2,3]</span><br><span class="line"></span><br><span class="line">元组Tuple</span><br><span class="line">let arr:[string,boolean] = ['字符串', true]</span><br></pre></td></tr></tbody></table></figure><h3 id="4、Enum枚举-（ts补充）void"><a href="#4、Enum枚举-（ts补充）void" class="headerlink" title="4、Enum枚举 （ts补充）void"></a>4、Enum枚举 （ts补充）void</h3><p>使用枚举类型可以为一组赋值赋予友好的名字</p><p>void没有返回值的类型，打印undefined</p><h3 id="5、any-amp-unknown"><a href="#5、any-amp-unknown" class="headerlink" title="5、any &amp; unknown"></a>5、any &amp; unknown</h3><p><code>unknown</code>与<code>any</code>的最大区别是：</p><p>unknown是 top type(任何类型都是它的 subtype) , 而 <code>any</code> 既是 <code>top type</code>, 又是 <code>bottom type</code> (它是任何类型的 <code>subtype</code> ) , 这导致 <code>any</code> 基本上就是放弃了任何类型检查。因为<code>any</code>既是<code>top type</code>, 又是 <code>bottom type</code>，所以任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何类型。但<code>unknown</code> 只是 <code>top type</code>，任何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code>，因为只有它俩是<code>top type</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// any`会跳过类型检查器对值的检查，任何值都可以赋值给`any`类型，它通常被称为`top type</span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br><span class="line">// unknown与any一样，所有类型都可以分配给unknown:</span><br><span class="line">let notSure: unknown = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br></pre></td></tr></tbody></table></figure><h3 id="6、object-amp-never"><a href="#6、object-amp-never" class="headerlink" title="6、object &amp; never"></a>6、object &amp; never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。</p><p>==<code>never</code>与其他类型的联合后，是没有<code>never</code>的==</p><p>值会永不存在的两种情况：</p><ol><li><p>如果一个函数执行时抛出了<strong>异常</strong>，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</p></li><li><p>函数中执行无限循环的代码（<strong>死循环</strong>），使得程序永远无法运行到函数返回值那一步，永不存在返回。</p></li><li><p><code>never</code>类型同<code>null</code>和<code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型：</p></li><li><p>但是没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外），即使<code>any</code>也不可以赋值给<code>never</code>：</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    function getobj(obj:object):object {</span><br><span class="line">        console.log(obj)</span><br><span class="line">        return {</span><br><span class="line">            name: 'kakaxi'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    console.log(getobj({name: '213'}));</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4、类型（联合-断言-交叉-推断）"><a href="#1-4、类型（联合-断言-交叉-推断）" class="headerlink" title="1.4、类型（联合 断言 交叉 推断）"></a>1.4、类型（联合 断言 交叉 推断）</h2><h3 id="1-1、联合类型"><a href="#1-1、联合类型" class="headerlink" title="1.1、联合类型"></a>1.1、联合类型</h3><p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。当任意属性使用联合类型且属性中存在可选属性时，需要联合<code>undefined</code>类型，否则编译报错，原因显而易见，因为可选属性可有可无</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: string | number</span><br><span class="line">a = 'ok',</span><br><span class="line">a = 11</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、类型断言"><a href="#1-2、类型断言" class="headerlink" title="1.2、类型断言"></a>1.2、类型断言</h3><p>类型断言好比其它语言里的类型转换，类型转换通常发生在你比<code>TS</code>更了解某个值的详细信息的时候。==(相当于告诉编译器，我知道我是什么类型，知道在干什莫，相信我！按我说的处理)==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 类型断言两种方法&lt;&gt; he as</span><br><span class="line">// 例：&lt;&gt;断定变量str为字符串类型</span><br><span class="line">(&lt;string&gt;str)</span><br><span class="line">// as方法</span><br><span class="line">(str as string)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、类型推断"><a href="#1-3、类型推断" class="headerlink" title="1.3、类型推断"></a>1.3、类型推断</h3><p>如果没有指定明确的类型，那么TS会按照类型推论的规则推断出一个类型，如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</p><h3 id="1-4、交叉类型"><a href="#1-4、交叉类型" class="headerlink" title="1.4、交叉类型"></a>1.4、交叉类型</h3><p>==交叉类型取的多个类型的并集，但是如果<code>key</code>相同但是类型不同，则该<code>key</code>为<code>never</code>类型==</p><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code>定义交叉类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface A {</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">}</span><br><span class="line">interface B {</span><br><span class="line">  name: string,</span><br><span class="line">  gender: string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a: A &amp; B = { // OK</span><br><span class="line">    name: "兔兔",</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: "男"</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5、接口"><a href="#1-5、接口" class="headerlink" title="1.5、接口"></a>1.5、接口</h2><p>接口是对象状态（属性）和行为（方法）的抽象（描述）</p><p>（接口是一种类型 规范 规则 约束 能力）</p><p>可选属性readonly 只读属性？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Props { </span><br><span class="line">  readonly name: string; </span><br><span class="line">  age: number; </span><br><span class="line">  money?: number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于数组，<code>TS</code>还有<code>ReadonlyArray&lt;T&gt;</code>类型，此类型将数组的所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><p>==<code>readonly</code>声明的只读数组类型与<code>ReadonlyArray</code>声明的只读数组类型，二者等价==</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口继承接口使用关键字extends ，继承的本质是复制，抽出共同的代码，所以子接口拥有父接口的类型定义</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Shape {</span><br><span class="line">name: string</span><br><span class="line">}</span><br><span class="line">interface Square extends Shape {</span><br><span class="line">age: number</span><br><span class="line">}</span><br><span class="line">let square: Square = {name: '雷'， age: 18} </span><br><span class="line">接口可以多继承，大部分语言是不支持多继承的，原因是会引发混乱</span><br></pre></td></tr></tbody></table></figure><p><img src="image-20210907172322403.png" alt="image-20210907172322403"></p><h3 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h3><p>采用函数表达式接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc {</span><br><span class="line">(source: string, subString:string): boolean</span><br><span class="line">}</span><br><span class="line">// 左侧进行限制 限制参数为两个且必须为字符串类型，返回值必须为布尔型</span><br><span class="line">let mySearch: SearchFunc = function(source: string, subString:string) {</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt;-1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h2><h3 id="1-1、-函数声明-amp-函数表达式"><a href="#1-1、-函数声明-amp-函数表达式" class="headerlink" title="1.1、 函数声明 &amp; 函数表达式"></a>1.1、 函数声明 &amp; 函数表达式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">function sum(x:number, y:number) {</span><br><span class="line">return x + y</span><br><span class="line">}</span><br><span class="line">// 表达式</span><br><span class="line">let mysum:(x:number, y:number) =&gt; number = function(x;number, y:number):number {</span><br><span class="line">    return x + y</span><br><span class="line">}</span><br><span class="line">// 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。切忌与ES6的箭头函数混淆了。</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、函数中的this声明"><a href="#1-2、函数中的this声明" class="headerlink" title="1.2、函数中的this声明"></a>1.2、函数中的<code>this</code>声明</h3><p>ts会通过代码流分析出this是属于什么类型，，当然我们也可以明确的指定函数中的this是什么类型，==this类型变量必须放在参数的首位==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj {</span><br><span class="line">    fn: (this: Obj, name: string) =&gt; void;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let obj: Obj = {</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let rab: Obj ={</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj.fn("兔兔"); // OK</span><br><span class="line">obj.fn.call(rab, "兔兔"); // OK</span><br><span class="line">obj.fn.call(window, "兔兔"); // Error: this 应该为 Obj 类型</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、参数"><a href="#1-3、参数" class="headerlink" title="1.3、参数"></a>1.3、参数</h3><p><code>可选参数</code></p><p>​    参数后加问号（？）注：==可选参数后面不允许再出现必需参数==</p><p><code>参数默认值</code></p><p>​    在函数定义时，参数内直接赋值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = 'Cat') {</span><br><span class="line">    return firstName + ' ' + lastName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <code>剩余参数</code></p><p>同js，用 … 表示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) {</span><br><span class="line">    items.forEach(function(item) {</span><br><span class="line">        array.push(item);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4、重载"><a href="#1-4、重载" class="headerlink" title="1.4、重载"></a>1.4、重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p><code>重载</code>的概念在学<code>JAVA</code>（<a href="https://link.juejin.cn/?target=https://www.runoob.com/java/java-override-overload.html"><code>JAVA中的重载</code></a>）的时候接触到的，<code>JS</code>是没有这个概念的，<code>TS</code>的重载感觉更应该称之为<code>函数签名重载</code>。因为最后函数实现的内部还是依赖判断类型来处理，前面的函数定义只是为了精确表达输入类型对应的输出类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string | void {</span><br><span class="line">    if (typeof x === 'number') {</span><br><span class="line">        return Number(x.toString().split('').reverse().join(''));</span><br><span class="line">    } else if (typeof x === 'string') {</span><br><span class="line">        return x.split('').reverse().join('');</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-7、-类"><a href="#1-7、-类" class="headerlink" title="1.7、 类"></a>1.7、 类</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>public  属性修饰符默认为<code>public</code>公共的，即类的属性、方法可以在外部访问</li><li>private  与<code>public</code>相对，私有修饰符，即类的属性、方法不可以在外部访问</li><li>protected 修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在<strong>派生类</strong>中仍然可以访问。注意，这里是<strong>派生类中</strong>，而不是<strong>实例、子类实例</strong>。</li><li>readonly 只读属性修饰符 构造函数中可以对只读属性进行修改  <img src="image-20210910114715199.png" alt="image-20210910114715199"></li><li>发生继承关系后类与类的叫法<img src="image-20210909200925647.png" alt="image-20210909200925647"></li></ul><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>我们也可以在类的内部方法上对参数使用<code>public、private、protected</code>修饰符，它的作用是可以更方便地让我们在一个地方定义并初始化一个成员。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Animal {</span><br><span class="line">    constructor(public name: string, private age: number, protected sex: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="接口实现类"><a href="#接口实现类" class="headerlink" title="接口实现类"></a>接口实现类</h3><p><code>TypeScript</code> 也能够用接口来明确的强制一个类去符合某种契约。类去实现接口，这里使用关键字<code>implements</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 一个类可以实现多个接口</span><br><span class="line">interface Age {</span><br><span class="line">  age: number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Title{</span><br><span class="line">  title: string;</span><br><span class="line">}</span><br><span class="line">class title implements Title, Age{</span><br><span class="line">  title: string = '兔兔';</span><br><span class="line">  age: number = 18;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用, 不允许被实例化。 不同于接口，抽象类可以包含成员的实现细节。 </p><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p><p><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department {</span><br><span class="line">    constructor(public name: string) {</span><br><span class="line">    }</span><br><span class="line">    printName(): void {</span><br><span class="line">        console.log('Department name: ' + this.name);</span><br><span class="line">    }</span><br><span class="line">    abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">}</span><br><span class="line">class AccountingDepartment extends Department {</span><br><span class="line">    constructor() {</span><br><span class="line">        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">    }</span><br><span class="line">    printMeeting(): void {</span><br><span class="line">        console.log('The Accounting Department meets each Monday at 10am.');</span><br><span class="line">    }</span><br><span class="line">    generateReports(): void {</span><br><span class="line">        console.log('Generating accounting reports...');</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let department: Department; // OK：允许创建一个对抽象类型的引用</span><br><span class="line">department = new Department(); // Error: 不能创建一个抽象类的实例</span><br><span class="line">department = new AccountingDepartment(); // OK：允许对一个抽象子类进行实例化和赋值</span><br><span class="line">department.printName(); // OK</span><br><span class="line">department.printMeeting(); // OK</span><br><span class="line">department.generateReports(); // Error: 方法在声明的抽象类中不存在</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-8、-泛型-lt-gt"><a href="#1-8、-泛型-lt-gt" class="headerlink" title="1.8、 泛型<>"></a>1.8、 泛型&lt;&gt;</h2><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王秋霞</title>
      <link href="/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/"/>
      <url>/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/</url>
      
        <content type="html"><![CDATA[<p>大爷今年六十花甲，穿着皮裤叼着雪茄，精神抖擞红光满颊，钞票大把塞满皮夹，欲求一女共度晚霞，诚心征婚就在当下，愿那女子年纪不大，做事温柔不像三八。唠唠家常说说闲话</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
