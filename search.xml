<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git笔记</title>
      <link href="/2021/09/29/git%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/09/29/git%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git笔记"><a href="#Git笔记" class="headerlink" title="Git笔记"></a>Git笔记</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>Git是分布式管理仓库，而SVN是集中式（CVS）管理的代表。CVS是保存文件修改的历史记录（文件变更的列表），Git是记录文件及其修改的快照并存储相应索引。</p><h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h2><h3 id="2-1-安装配置"><a href="#2-1-安装配置" class="headerlink" title="2.1 安装配置"></a>2.1 安装配置</h3><h4 id="2-1-1-安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。"><a href="#2-1-1-安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。" class="headerlink" title="2.1.1 安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。"></a>2.1.1 安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "John Doe"</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-2-检查配置信息"><a href="#2-1-2-检查配置信息" class="headerlink" title="2.1.2 检查配置信息"></a>2.1.2 检查配置信息</h4><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></tbody></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 git config &lt;key&gt;： 来检查 Git 的某一项配置<br>可以根据key修改以上的值：git config &lt;key&gt; &lt;value&gt;  </p><h2 id="1-把本地代码推到远程仓库"><a href="#1-把本地代码推到远程仓库" class="headerlink" title="1. 把本地代码推到远程仓库"></a>1. 把本地代码推到远程仓库</h2><p>1.1 上github新建仓库，不选新建README，懒得再解决冲突<br>1.2 （先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库，记得创建.gitignore文件忽略上传某些文件。  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  </span><br></pre></td></tr></tbody></table></figure><p>1.3 把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .  </span><br></pre></td></tr></tbody></table></figure><p>1.4 用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m 'first commit'  </span><br></pre></td></tr></tbody></table></figure><p>1.5 关联到远程库  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你的远程库地址  </span><br></pre></td></tr></tbody></table></figure><p>1.6 获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master  </span><br></pre></td></tr></tbody></table></figure><p>1.7 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master  </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6入门学习</title>
      <link href="/2021/09/29/es6%E5%88%9D%E5%A7%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/29/es6%E5%88%9D%E5%A7%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6标准入门学习总结"><a href="#ES6标准入门学习总结" class="headerlink" title="ES6标准入门学习总结"></a>ES6标准入门学习总结</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h2 id="2-let和const"><a href="#2-let和const" class="headerlink" title="2. let和const"></a>2. let和const</h2><p>const申明的常量只是在内存中的地址不变，指针不变。如果常量是个复杂类型，依然可以修改。如果把一个常量再次赋值给新变量，再覆盖新变量，常量是不会修改的。  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = { <span class="attr">age</span>: <span class="number">29</span> };</span><br><span class="line"><span class="keyword">let</span> b =  a;</span><br><span class="line">b.age = <span class="number">30</span>;  <span class="comment">// a.age === b.age === 30</span></span><br><span class="line">b = <span class="number">31</span>;  <span class="comment">// a依然是{ age: 30 }</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-变量解构赋值"><a href="#3-变量解构赋值" class="headerlink" title="3. 变量解构赋值"></a>3. 变量解构赋值</h2><h2 id="4-字符串扩展"><a href="#4-字符串扩展" class="headerlink" title="4. 字符串扩展"></a>4. 字符串扩展</h2><h3 id="4-1-ES6前常用的方法"><a href="#4-1-ES6前常用的方法" class="headerlink" title="4.1 ES6前常用的方法"></a>4.1 ES6前常用的方法</h3><p>4.1.1 String.fromCharCode(Unicode1,Unicode2,…,Unicoden)是String静态方法，参数是至少一个Unicode码，返回所有参数对应的字符组成的字符串。<br>4.1.2 stringObject.indexOf(searchvalue[,fromindex])默认从首字符开始检索，返回某个指定的字符串值在字符串中首次出现的位置，没有返回-1。<br>4.1.3 stringObject.lastIndexOf(searchvalue,fromindex)  </p><p>字符串新增方法  </p><p>正则扩展  </p><p>数值的扩展  </p><p>函数的扩展  </p><p>数组的扩展  </p><p>对象的扩展  </p><p>对象新增的方法  </p><p>Symbol  </p><p>set和map  </p><p>Proxy  </p><p>Reflect  </p><p>Promise  </p><p>Iterator和for…of  </p><p>Generatore  </p><p>Generator 的异步应用  </p><p>async  </p><p>class</p><p>  ES6之前实现一个类一般是通过工厂函数，修改原型链实现类的继承。ES6提供classAPI，使用extends继承。<br>  子类必须在constructor中首先调用super否则会报错(新建子类实例时)，因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br>  ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this<br>  super表示父类的构造函数，但是返回的是子类<br>  类中无this，只有实例才有</p><p>super指向父类（不是实例哦），constuctor默认返回的是实例，也可手动返回其他对象<br>如果父类constructor有参数，子类必须调用super，并且传入指定参数：既子类的constructor的参数必须包括父类constructor的参数，且子类必须调用super传入这些参数  </p><h2 id="22-class的继承"><a href="#22-class的继承" class="headerlink" title="22. class的继承"></a>22. class的继承</h2><p>  class语法本身是es5构造函数的语法上塘，定义的类的方法(非静态方法)本身是在原型链上添加方法  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">somemethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">    <span class="function"><span class="title">othermethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Object</span>.asign(A.prototype,{</span><br><span class="line">    <span class="function"><span class="title">somemethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">    <span class="function"><span class="title">othermethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>  constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor默认返回当前类的实例(this)，也可以返回指定上下文</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{}</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  如果有父类，还必须在constructor中调用super  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.x = x</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span> {</span><br><span class="line">        <span class="built_in">super</span>(x)</span><br><span class="line">        <span class="built_in">this</span>.y = y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  在new一个类时，先调用constructor方法，如果是子类，必须在constructor内先调用super(接受全部父类需要的参数)，先创建父类上下文，再创建子类上下文<br>  class内的方法不需要加function,可以在constructor中绑定this或使用箭头函数，否则经过赋值后的方法会改变this  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">text</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> {say} = <span class="keyword">new</span> Parent()</span><br><span class="line">say() <span class="comment">// Uncaught TypeError: Cannot read property 'firstname' of undefined</span></span><br><span class="line"><span class="keyword">const</span> {text} = Parent</span><br><span class="line">text() <span class="comment">// Uncaught TypeError: Cannot read property 'firstname' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.say = <span class="built_in">this</span>.say.bind(<span class="built_in">this</span>)</span><br><span class="line">    }</span><br><span class="line">    say = <span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> username = <span class="string">'nothing'</span></span><br><span class="line">    <span class="keyword">static</span> text1 = <span class="function">()=&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> {say} = <span class="keyword">new</span> Parent()</span><br><span class="line">say() <span class="comment">// 'Parent'</span></span><br><span class="line"><span class="keyword">const</span> {text} = Parent</span><br><span class="line">text() <span class="comment">// 'nothing'wqwqsdfsdf</span></span><br></pre></td></tr></tbody></table></figure><p>  第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><p>module  </p><p>module的加载实现  </p><p>编程风格  </p><p>读懂规格  </p><p>异步遍历器  </p><p>ArrayBuffer  </p><p>Decorator</p><p>作用域  </p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在函数、模块外申明的变量全局都可以访问。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inde.html</span></span><br><span class="line"><span class="comment">// 重点在type，如果是module，这段脚本就是es6module</span></span><br><span class="line">...</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>; <span class="comment">// 全局作用域</span></span><br><span class="line">b=<span class="number">13</span>; <span class="comment">// 使用效果如上，他实际上是挂到window上，可以被删除，但是a却不能</span></span><br></pre></td></tr></tbody></table></figure><h3 id="函数-局部作用域"><a href="#函数-局部作用域" class="headerlink" title="函数/局部作用域"></a>函数/局部作用域</h3><p>在函数内申明的变量只能在函数内访问（可以访问上一级变量；module也是函数）</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>this  </p><h3 id="块状作用域"><a href="#块状作用域" class="headerlink" title="块状作用域"></a>块状作用域</h3><p>{}中的代码；let、const</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for…in…针对object（array是object，arr.name=122,也会被遍历）,for针对array，for…of…都可以  </p><h2 id="帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）"><a href="#帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）" class="headerlink" title="帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）"></a><a href="https://blog.csdn.net/cc18868876837/article/details/81211729">帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）</a></h2><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>普通函数的this，谁调用只想谁，非严格模式找不到就指向window。箭头函数是绑定的父级的作用域，如果父级也是箭头函数，那就继续晚上找。obj={fn(){}},这是obj={fn:fucntion(){}}的简写，而不是箭头函数。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结常用的一些类库</title>
      <link href="/2021/09/29/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"/>
      <url>/2021/09/29/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总结常用的一些类库"><a href="#总结常用的一些类库" class="headerlink" title="总结常用的一些类库"></a>总结常用的一些类库</h1><h2 id="1-JS模板引擎"><a href="#1-JS模板引擎" class="headerlink" title="1. JS模板引擎"></a>1. JS模板引擎</h2><p>1.1 <a href="https://handlebarsjs.com/zh/">handlebars.js</a><br>1.2 <a href="https://ejs.bootcss.com/">ejs.js</a>  </p><blockquote><p>服务端和客户端都可以，捕获异常准确调试方便  </p></blockquote><p>1.3 <a href="https://aui.github.io/art-template/zh-cn/index.html">art-template.js</a>  </p><blockquote><p>分客户端（兼容IE8+，IE8需要加补丁），node端：express、koa，webpack端  </p></blockquote><h2 id="2-JS库"><a href="#2-JS库" class="headerlink" title="2. JS库"></a>2. JS库</h2><h3 id="1-jQuery，zepto-js"><a href="#1-jQuery，zepto-js" class="headerlink" title="1. jQuery，zepto.js"></a>1. <a href="https://jquery.com/">jQuery</a>，<a href="http://www.zeptojs.cn/">zepto.js</a></h3><blockquote><p>jQuery兼容许多老浏览器版本，1.x兼容到IE6，2.x只是相较于1.x移除了IE6/7/8的兼容，3.x相较于2.x增加了许多新特性。可以参照<a href="https://www.hangge.com/blog/cache/detail_2228.html">jQuery - 不同版本的差异汇总（版本选择建议</a>、<a href="https://www.hangge.com/blog/cache/detail_2235.html">jQuery - jQuery3的新特性汇总（附样例）</a><br>zepto相较于jQuery，则是针对Chrome和safria，更加轻量<br><a href="https://jqueryvalidation.org/documentation/">jquery-validation</a>表单验证插件。(jQuery, tested with 1.7.2, 1.8.3, 1.9.1, 1.11.1, 3.1.1)</p></blockquote><h3 id="2-backbone-js"><a href="#2-backbone-js" class="headerlink" title="2. backbone.js"></a>2. <a href="http://www.zeptojs.cn/">backbone.js</a></h3><blockquote><p>MVC前端框架<a href="https://github.com/the5fire/backbonejs-learning-note">Backbone.js入门教程第二版</a>  </p></blockquote><h3 id="3-popper-js"><a href="#3-popper-js" class="headerlink" title="3. popper.js"></a>3. <a href="https://popper.js.org/">popper.js</a></h3><blockquote><p>元素定位类库，许多UI框架都在使用。</p></blockquote><h2 id="koa2"><a href="#koa2" class="headerlink" title="koa2"></a>koa2</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>koa-views,koa-swig,ejs,handlebars,art-template<br>模板引擎也分服务端和客户端，node端得搭配koa-views、koa-swig、koa-ejs等使用。这里只讲<a href="mailto:koa-views@6.2.1">koa-views@6.2.1</a>使用中路径问题,其内部使用get-paths(path, relPath, extension)这个库解析路径。</p><p><img src="./images/koa2_demo_koa-views_path.jpg" alt="项目路径"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">"@koa/router"</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">"koa-views"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// views方法第一个参数就是get-paths接收的第一个参数，还可以是绝/相对路径，extension就是第三个参数。路由中render的第一个参数就是get-paths第二个参数(这是个坑，不是路径,可以有后缀名)。解析到文件会找下面的index文件。</span></span><br><span class="line">app.use(views(<span class="string">'views'</span>, {</span><br><span class="line">    <span class="attr">extension</span>: <span class="string">"ejs"</span></span><br><span class="line">}));</span><br><span class="line">router.get(<span class="string">"/users"</span>, <span class="keyword">async</span> (ctx, next) =&gt; {</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">"users"</span>, {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">"用户管理"</span></span><br><span class="line">    })</span><br><span class="line">});</span><br><span class="line">router.get(<span class="string">"/users/admin"</span>, <span class="keyword">async</span> (ctx, next) =&gt; {</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'users/admin'</span>, {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">"admin"</span></span><br><span class="line">    })</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>ejs  </p><blockquote><p>服务端：npm i ejs<br>客户端：Go to the <a href="https://github.com/mde/ejs/releases/latest">Latest Release</a>, download<br><code>./ejs.js</code> or <code>./ejs.min.js</code>. Alternately, you can compile it yourself by cloning<br>the repository and running <code>jake build</code> (or <code>$(npm bin)/jake build</code> if jake is<br>not installed globally).也可以<code>npx jake buld</code></p></blockquote><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>koa-static，koa-static-cache  </p><h2 id="3-打包工具"><a href="#3-打包工具" class="headerlink" title="3 打包工具"></a>3 打包工具</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a><a href="https://www.webpackjs.com/">webpack</a></h3><h3 id="parceljs"><a href="#parceljs" class="headerlink" title="parceljs"></a><a href="https://parceljs.org/">parceljs</a></h3><h3 id="gulp-v4-x"><a href="#gulp-v4-x" class="headerlink" title="gulp v4.x"></a><a href="https://www.gulpjs.com.cn/">gulp v4.x</a></h3><h3 id="Rollup-js"><a href="#Rollup-js" class="headerlink" title="Rollup.js"></a><a href="https://www.rollupjs.com/">Rollup.js</a></h3><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h3 id="dotenv"><a href="#dotenv" class="headerlink" title="dotenv"></a><a href="https://www.npmjs.com/package/dotenv">dotenv</a></h3><p>识别文件(.env)中的变量，并添加到process.env中  </p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a><a href="https://github.com/demopark/sequelize-docs-Zh-CN">sequelize</a></h4><p>Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能.</p><h3 id="node端生成、操作DOMjsdom"><a href="#node端生成、操作DOMjsdom" class="headerlink" title="node端生成、操作DOMjsdom"></a>node端生成、操作DOM<a href="https://www.npmjs.com/package/jsdom">jsdom</a></h3><h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><h3 id="tinymce（无依赖）"><a href="#tinymce（无依赖）" class="headerlink" title="tinymce（无依赖）"></a><a href="https://www.tiny.cloud/docs/">tinymce</a>（无依赖）</h3><h3 id="ckeditor（无依赖）"><a href="#ckeditor（无依赖）" class="headerlink" title="ckeditor（无依赖）"></a><a href="https://ckeditor.com/">ckeditor</a>（无依赖）</h3><h3 id="draft-js（react，facebook开源）"><a href="#draft-js（react，facebook开源）" class="headerlink" title="draft.js（react，facebook开源）"></a><a href="https://draftjs.org/docs/getting-started">draft.js</a>（react，facebook开源）</h3><h3 id="Lin-CMS"><a href="#Lin-CMS" class="headerlink" title="Lin CMS"></a><a href="http://doc.cms.7yue.pro/">Lin CMS</a></h3><p>可以用koa、flask、spring-boot搭建  </p><h2 id="4-popper-js弹窗"><a href="#4-popper-js弹窗" class="headerlink" title="4 popper.js弹窗"></a>4 <a href="https://popper.js.org/">popper.js弹窗</a></h2><h2 id="5-网站运行状态管理"><a href="#5-网站运行状态管理" class="headerlink" title="5 网站运行状态管理"></a>5 网站运行状态管理</h2><p>不过一般来说有后台监视系统</p><ol><li><a href="https://github.com/juliomrqz/statusfy">statusfy</a>  </li><li><a href="https://github.com/CachetHQ/Cachet">Cachet</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劝退指南</title>
      <link href="/2021/09/29/%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/"/>
      <url>/2021/09/29/%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Javascript模块化编程（一）：模块的写法</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>图片分为banner（大图）、普通图片（需要压缩）、小图和图标(可以制作雪碧图、base64等)，所以都需要单独建目录针对处理。</p></li><li><p>样式分为公共和模块独有，公共部分又分common.less、variable.less、reset.less，其中common.less又可以单独拆分：比如常见的容器、整体布局可以分为一类，重置UI框架的样式可以分为一类。然后按序引入一个文件。variable.less可以使用插件。  </p></li><li><p>API可以根据需要分为url和method，配制成对象。常用的也可以封装成方法。  </p></li><li><p>项目中使用的正则全部统一管理，表单验证规则、提示语等根据UI框架设置成json。  </p></li><li><p>常用方法放到util目录。  </p></li><li><p>assets：静态文件目录，可以使用webpack’卓一些处理；static：静态文件，不用做处理；  </p></li><li><p>常用的一些前后端对接的变量：数据字典，单独存储。</p></li><li><p>先讲清楚需求，客户端兼容性，移动端还是PC端，客户端对数据持久化的程度要求，路由切换动效，全局或者局部loading，默认字体及其大小颜色、主题色等。后台数据缺省值，数据模型、名称尽量统一。</p></li><li><p>写详细设计：需求文档中的需求说明、原型、前端交互及数据交互的流程图、接口文档（请求体：报文、method、request，响应体：报文、data、status、message），需求及原型评审、UI评审、详设评审、接口文档评审。  </p></li><li><p>组件一般只解决交互、数据传递、数据通用转换等需求，页面才处理数据请求分发等业务。</p></li><li><p>约定大于大于配置，不要在某些问题上纠结，好的习惯变成约定以配置实现。  </p></li><li><p>与后台约定好接口的status、message，数据不要嵌套太深。  </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6入门学习</title>
      <link href="/2021/09/29/%E6%AD%A3%E5%88%99%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/09/29/%E6%AD%A3%E5%88%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p><p><a href="https://juejin.cn/post/6844903487155732494">JS 正则表达式完整教程（略长）</a></p><p><a href="https://cloud.tencent.com/developer/chapter/13619">腾讯云文档</a></p><h2 id="1-1-匹配标志"><a href="#1-1-匹配标志" class="headerlink" title="1.1 匹配标志"></a>1.1 匹配标志</h2><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>g</td><td>全局搜索</td></tr><tr><td>m</td><td>多行匹配</td></tr><tr><td>i</td><td>忽略大小写</td></tr><tr><td>y</td><td>执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始(lastIndex)</td></tr><tr><td>s</td><td>允许<code>.</code> 匹配换行符</td></tr><tr><td>u</td><td>使用 unicode 码的模式进行匹配</td></tr></tbody></table><ul><li>正则对象都有个 lastIndex 属性，只读（但是 js 没有严格语法限制，可以修改），只有正则使用了 global 标志才会在匹配成功是修改 lastIndex 的值，失败置 0。使用 sticky 标志，只会从正则的 lastIndex 开始匹配，但是不会修改它的值。</li><li>多行匹配只有在字符串中有换行符时才有意义，有换行符时^、$表示每行开头结尾，如果不使用^或$那么也没必要使用 m 标志。</li><li>除了 i，其他基本没使用过。</li></ul><h2 id="1-2-匹配模式"><a href="#1-2-匹配模式" class="headerlink" title="1.2 匹配模式"></a>1.2 匹配模式</h2><p>匹配字符或者匹配位置。</p><h2 id="1-3-RegExp-和-String-的一些常用方法"><a href="#1-3-RegExp-和-String-的一些常用方法" class="headerlink" title="1.3 RegExp 和 String 的一些常用方法"></a>1.3 RegExp 和 String 的一些常用方法</h2><p>String：</p><blockquote><p>replace<br>search<br>match<br>matchAll<br>split</p></blockquote><p>RegExp：</p><blockquote><p>test<br>exec<br>compile</p></blockquote><p>正则实际匹配结果看 match 和 matchAll，test 只是判断字符串是否满足正则要求。<br>search 相当于 indexOf 于 Array，找到满足正则的第一个字符集首字符位置，否则返回-1。<br>exec 开启 g 或 y 每次调用会修改 lastIndex。<br>matchAll 返回的是迭代器。</p><p>重点说 replace：str.replace(regexp|substr, newSubStr|function)</p><blockquote><p>第一个参数：可以使正则，会处理全部匹配的字符。可以使字符串，只处理第一个相等字符。<br>第二个参数：可以使特殊字符串，$&amp;表示被整个正则匹配到的字符，可以修饰字符串；$n 表示每个子表达式匹配的字符，可以重新组合或者提取字符串（子表达式没匹配到的会被忽略）；$`、$‘表示匹配字符左边、右边全部类容，可以修饰字符串。可以使函数，参数是[match 的字符，…子表达式匹配的结果,位置，输入值]，返回值替换匹配字符，如果开启 g 或 m 会多次调用。</p></blockquote><table><thead><tr><th>变量名</th><th>代表值</th></tr></thead><tbody><tr><td>$$</td><td>插入一个 “$”</td></tr></tbody></table><h2 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4 问题"></a>1.4 问题</h2><ol><li><p>一道面试题<br>![一道面试题][reg_g]</p><details>  <summary><font color="#56b6a7">答案</font></summary>  <pre><code>  truetruefalsetrue// 在设置g或y模式，RegExp 对象是有状态的。他们会将上次成功匹配后的位置记录在 lastIndex 属性中。// 全局匹配会记录上次匹配到的位置，然后下一次从上一次的位置开始匹配，失败时会重置lastIndex为0。  </code></pre></details></li><li><p>一道面试题：使用正则实现 String.trim()</p><details>  <summary><font color="#56b6a7">答案</font></summary>  <pre><code>  String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")}  </code></pre></details></li><li><p>实现一个正则：不能以空白字符开头和结束，至少一个字符</p><details>  <summary><font color="#56b6a7">我的</font></summary>  <pre><code>   /^\S(.*\S)?$/ /^\S{1}$|^\S+.*\S+$/g  </code></pre></details></li><li><p>一道面试题：使用正则实现 String.trim()</p></li><li><p>不同系统换行符的区：windows：\n\r，mac：\r，Unix：\n。不同系统处理文件时要注意。</p></li><li><p>表达式里，有些特殊符号要在前面加\转义。比如：根据一个字符串生成一个正则，就需要转义正则里的全部特殊符号，不然直接生成正则是按转移后的字符生成的。</p></li><li><p>讲解两个正则：</p></li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机号</span></span><br><span class="line">/^((\+|<span class="number">00</span>)<span class="number">86</span>)?<span class="number">1</span>((<span class="number">3</span>[\d])|(<span class="number">4</span>[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>])|(<span class="number">5</span>[<span class="number">0</span>-<span class="number">3</span>,<span class="number">5</span>-<span class="number">9</span>])|(<span class="number">6</span>[<span class="number">5</span>-<span class="number">7</span>])|(<span class="number">7</span>[<span class="number">0</span>-<span class="number">8</span>])|(<span class="number">8</span>[\d])|(<span class="number">9</span>[<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>]))\d{<span class="number">8</span>}$/</span><br><span class="line"><span class="comment">// 密码强度校验：最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span></span><br><span class="line"><span class="regexp">/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span></span><br></pre></td></tr></tbody></table></figure><p>1.5 总结</p><ol><li>与：/ppp/，或：/p|p|p/，非：/[^ppp]/。</li><li>正则终究匹配的是字符或者位置。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端总结</title>
      <link href="/2021/09/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%80%E4%BA%9B/"/>
      <url>/2021/09/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%80%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="H5移动端开发总结"><a href="#H5移动端开发总结" class="headerlink" title="H5移动端开发总结"></a>H5移动端开发总结</h1><h4 id="移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等"><a href="#移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等" class="headerlink" title="移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等"></a>移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>{</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这有个问题：body或者html依旧不是相对屏幕固定的，上下滑动会造成背景图位移等(Safari)，以下可解决：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>{</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是在移动端输入时，软键盘弹起解决页面被隐藏或者被顶起时，会有副作用。</p><h4 id="适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置"><a href="#适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置" class="headerlink" title="适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置"></a>适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意这里是100倍，因为一般除不尽，多取几位缩小误差。所以应该有个css单位变量是htmlFontsize*1/100</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// spa完全可以放到body尾部</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> htmlFontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">375</span> * <span class="number">100</span> + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bodyFontSize = <span class="string">'16px'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> styleDom = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span></span><br><span class="line"><span class="javascript">        styleDom.innerHTML = <span class="string">'html{font-size:'</span> + htmlFontSize + <span class="string">'!important;}body{font-size:'</span> + bodyFontSize + <span class="string">'!important;}'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(styleDom)</span></span><br><span class="line"><span class="javascript">    })();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="禁止缩放和双击放大（包括Safari）"><a href="#禁止缩放和双击放大（包括Safari）" class="headerlink" title="禁止缩放和双击放大（包括Safari）"></a>禁止缩放和双击放大（包括Safari）</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastTouchEnd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (event.touches.length &gt; <span class="number">1</span>) {</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">if</span> (now - lastTouchEnd &lt;= <span class="number">300</span>) {</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">    lastTouchEnd = now;</span><br><span class="line">}, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'gesturestart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    event.preventDefault();</span><br><span class="line">});</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'dblclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    event.preventDefault();</span><br><span class="line">})</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="Safari滚动到动态列表时滑动出问题"><a href="#Safari滚动到动态列表时滑动出问题" class="headerlink" title="Safari滚动到动态列表时滑动出问题"></a>Safari滚动到动态列表时滑动出问题</h4><p>动态创建的列表高度没有预设高度，在动态创建列表（ajax等）后，浏览器没有计算好，导致滚动失败。解决办法：设置需要滚动的容器的(min-)height，撑起容器。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ts</title>
      <link href="/2021/09/27/%E5%85%B3%E4%BA%8Ets/"/>
      <url>/2021/09/27/%E5%85%B3%E4%BA%8Ets/</url>
      
        <content type="html"><![CDATA[<h1 id="1、TS初见"><a href="#1、TS初见" class="headerlink" title="1、TS初见"></a>1、TS初见</h1><h2 id="1-1、为什么要有-TypeScript"><a href="#1-1、为什么要有-TypeScript" class="headerlink" title="1.1、为什么要有 TypeScript"></a>1.1、为什么要有 TypeScript</h2><p>TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。</p><p>`TypeScript的初衷就是为了做类型检查，提早发现错误，所以「类型」是其最核心的特性。当然它只是给出你代码可能不会按预期执行的警告，比如你未按照声明的类型传参，你的代码还是可以运行的。这一点与强类型语言还是有本质的区别，强类型语言会直接导致编译不通过，因为TypeScript只是转译。跟JavaScript不同，TypeScript文件后缀使用 .ts扩展名。浏览器是不识别 .ts 文件，所以使用时必须提前把 TS 代码转换成 JavaScript 代码。这个转换过程被称为转译，编译和转译的微小差别在于：</p><p>编译是把源码转变成另一种语言<br>转译是把源码转变另一个相同抽象层级的语言</p><h2 id="1-2、前提准备"><a href="#1-2、前提准备" class="headerlink" title="1.2、前提准备"></a>1.2、前提准备</h2><ul><li>安装 node环境下安装 npm install -g typescript</li><li>手动编译 tsc  **.ts</li><li>vscode自动编译 tsc –init 在tsconfig.js中配置，在终端打开tsc监视即可</li><li>ts语法提示错误，不影响js的编译，因为js是弱类型语言（如类型注解不通过）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 类型注解 一种轻量级的为函数或变量添加约束</span><br><span class="line">(() =&gt; {</span><br><span class="line">    function showMsg(str:String) {</span><br><span class="line">        return str + '123214'</span><br><span class="line">    }</span><br><span class="line">    let str = "woshi"</span><br><span class="line">    console.log(showMsg(str));</span><br><span class="line">    </span><br><span class="line">})()</span><br><span class="line"></span><br><span class="line">// 接口演示 定义接口</span><br><span class="line">(() =&gt; {</span><br><span class="line">    interface Iperson{</span><br><span class="line">        fristName:string,</span><br><span class="line">        lastName:string</span><br><span class="line">    }</span><br><span class="line">    // 输出对象</span><br><span class="line">    function showFullName(person:Iperson) {</span><br><span class="line">        return person.fristName + person.lastName</span><br><span class="line">    }</span><br><span class="line">    // 定义对象</span><br><span class="line">    const person = {</span><br><span class="line">        fristName: 'dongfnag',</span><br><span class="line">        lastName: 'yuechu'</span><br><span class="line">    }</span><br><span class="line">    // 打印</span><br><span class="line">    console.log(showFullName(person))</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3、基础类型"><a href="#1-3、基础类型" class="headerlink" title="1.3、基础类型"></a>1.3、基础类型</h2><h3 id="1、布尔-数字-字符串"><a href="#1、布尔-数字-字符串" class="headerlink" title="1、布尔 数字 字符串"></a>1、布尔 数字 字符串</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a:boolean = true</span><br><span class="line">let b:number = 1010</span><br><span class="line">let c:string = '字符串'</span><br><span class="line"></span><br><span class="line">//字符串可与数字拼接 TS中变量一开始是什么类型就只能用这个类型，不允许混用</span><br></pre></td></tr></tbody></table></figure><h3 id="2、undefined-amp-null"><a href="#2、undefined-amp-null" class="headerlink" title="2、undefined &amp; null"></a>2、undefined &amp; null</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let und:undefined = undefined</span><br><span class="line">let nul:null = null</span><br><span class="line">// 给其他类型赋予</span><br><span class="line">let num:number = null</span><br><span class="line">let num:number = undefined</span><br><span class="line"></span><br><span class="line">// undefined和null 可以作为其他类型的子类型，可以将undef和null赋予其他类型（需关闭ts严格模式）</span><br></pre></td></tr></tbody></table></figure><h3 id="3、-数组和元组"><a href="#3、-数组和元组" class="headerlink" title="3、 数组和元组"></a>3、 数组和元组</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组定义方式1</span><br><span class="line">let arr:number[] = [10,20,30]</span><br><span class="line">数组定义方式2(泛型写法)</span><br><span class="line">let arr:Array&lt;number&gt; = [1,2,3]</span><br><span class="line"></span><br><span class="line">元组Tuple</span><br><span class="line">let arr:[string,boolean] = ['字符串', true]</span><br></pre></td></tr></tbody></table></figure><h3 id="4、Enum枚举-（ts补充）void"><a href="#4、Enum枚举-（ts补充）void" class="headerlink" title="4、Enum枚举 （ts补充）void"></a>4、Enum枚举 （ts补充）void</h3><p>使用枚举类型可以为一组赋值赋予友好的名字</p><p>void没有返回值的类型，打印undefined</p><h3 id="5、any-amp-unknown"><a href="#5、any-amp-unknown" class="headerlink" title="5、any &amp; unknown"></a>5、any &amp; unknown</h3><p><code>unknown</code>与<code>any</code>的最大区别是：</p><p>unknown是 top type(任何类型都是它的 subtype) , 而 <code>any</code> 既是 <code>top type</code>, 又是 <code>bottom type</code> (它是任何类型的 <code>subtype</code> ) , 这导致 <code>any</code> 基本上就是放弃了任何类型检查。因为<code>any</code>既是<code>top type</code>, 又是 <code>bottom type</code>，所以任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何类型。但<code>unknown</code> 只是 <code>top type</code>，任何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code>，因为只有它俩是<code>top type</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// any`会跳过类型检查器对值的检查，任何值都可以赋值给`any`类型，它通常被称为`top type</span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br><span class="line">// unknown与any一样，所有类型都可以分配给unknown:</span><br><span class="line">let notSure: unknown = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br></pre></td></tr></tbody></table></figure><h3 id="6、object-amp-never"><a href="#6、object-amp-never" class="headerlink" title="6、object &amp; never"></a>6、object &amp; never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。</p><p>==<code>never</code>与其他类型的联合后，是没有<code>never</code>的==</p><p>值会永不存在的两种情况：</p><ol><li><p>如果一个函数执行时抛出了<strong>异常</strong>，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</p></li><li><p>函数中执行无限循环的代码（<strong>死循环</strong>），使得程序永远无法运行到函数返回值那一步，永不存在返回。</p></li><li><p><code>never</code>类型同<code>null</code>和<code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型：</p></li><li><p>但是没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外），即使<code>any</code>也不可以赋值给<code>never</code>：</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    function getobj(obj:object):object {</span><br><span class="line">        console.log(obj)</span><br><span class="line">        return {</span><br><span class="line">            name: 'kakaxi'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    console.log(getobj({name: '213'}));</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4、类型（联合-断言-交叉-推断）"><a href="#1-4、类型（联合-断言-交叉-推断）" class="headerlink" title="1.4、类型（联合 断言 交叉 推断）"></a>1.4、类型（联合 断言 交叉 推断）</h2><h3 id="1-1、联合类型"><a href="#1-1、联合类型" class="headerlink" title="1.1、联合类型"></a>1.1、联合类型</h3><p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。当任意属性使用联合类型且属性中存在可选属性时，需要联合<code>undefined</code>类型，否则编译报错，原因显而易见，因为可选属性可有可无</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: string | number</span><br><span class="line">a = 'ok',</span><br><span class="line">a = 11</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、类型断言"><a href="#1-2、类型断言" class="headerlink" title="1.2、类型断言"></a>1.2、类型断言</h3><p>类型断言好比其它语言里的类型转换，类型转换通常发生在你比<code>TS</code>更了解某个值的详细信息的时候。==(相当于告诉编译器，我知道我是什么类型，知道在干什莫，相信我！按我说的处理)==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 类型断言两种方法&lt;&gt; he as</span><br><span class="line">// 例：&lt;&gt;断定变量str为字符串类型</span><br><span class="line">(&lt;string&gt;str)</span><br><span class="line">// as方法</span><br><span class="line">(str as string)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、类型推断"><a href="#1-3、类型推断" class="headerlink" title="1.3、类型推断"></a>1.3、类型推断</h3><p>如果没有指定明确的类型，那么TS会按照类型推论的规则推断出一个类型，如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</p><h3 id="1-4、交叉类型"><a href="#1-4、交叉类型" class="headerlink" title="1.4、交叉类型"></a>1.4、交叉类型</h3><p>==交叉类型取的多个类型的并集，但是如果<code>key</code>相同但是类型不同，则该<code>key</code>为<code>never</code>类型==</p><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code>定义交叉类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface A {</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">}</span><br><span class="line">interface B {</span><br><span class="line">  name: string,</span><br><span class="line">  gender: string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a: A &amp; B = { // OK</span><br><span class="line">    name: "兔兔",</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: "男"</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5、接口"><a href="#1-5、接口" class="headerlink" title="1.5、接口"></a>1.5、接口</h2><p>接口是对象状态（属性）和行为（方法）的抽象（描述）</p><p>（接口是一种类型 规范 规则 约束 能力）</p><p>可选属性readonly 只读属性？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Props { </span><br><span class="line">  readonly name: string; </span><br><span class="line">  age: number; </span><br><span class="line">  money?: number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于数组，<code>TS</code>还有<code>ReadonlyArray&lt;T&gt;</code>类型，此类型将数组的所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><p>==<code>readonly</code>声明的只读数组类型与<code>ReadonlyArray</code>声明的只读数组类型，二者等价==</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口继承接口使用关键字extends ，继承的本质是复制，抽出共同的代码，所以子接口拥有父接口的类型定义</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Shape {</span><br><span class="line">name: string</span><br><span class="line">}</span><br><span class="line">interface Square extends Shape {</span><br><span class="line">age: number</span><br><span class="line">}</span><br><span class="line">let square: Square = {name: '雷'， age: 18} </span><br><span class="line">接口可以多继承，大部分语言是不支持多继承的，原因是会引发混乱</span><br></pre></td></tr></tbody></table></figure><p><img src="image-20210907172322403.png" alt="image-20210907172322403"></p><h3 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h3><p>采用函数表达式接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc {</span><br><span class="line">(source: string, subString:string): boolean</span><br><span class="line">}</span><br><span class="line">// 左侧进行限制 限制参数为两个且必须为字符串类型，返回值必须为布尔型</span><br><span class="line">let mySearch: SearchFunc = function(source: string, subString:string) {</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt;-1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h2><h3 id="1-1、-函数声明-amp-函数表达式"><a href="#1-1、-函数声明-amp-函数表达式" class="headerlink" title="1.1、 函数声明 &amp; 函数表达式"></a>1.1、 函数声明 &amp; 函数表达式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">function sum(x:number, y:number) {</span><br><span class="line">return x + y</span><br><span class="line">}</span><br><span class="line">// 表达式</span><br><span class="line">let mysum:(x:number, y:number) =&gt; number = function(x;number, y:number):number {</span><br><span class="line">    return x + y</span><br><span class="line">}</span><br><span class="line">// 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。切忌与ES6的箭头函数混淆了。</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、函数中的this声明"><a href="#1-2、函数中的this声明" class="headerlink" title="1.2、函数中的this声明"></a>1.2、函数中的<code>this</code>声明</h3><p>ts会通过代码流分析出this是属于什么类型，，当然我们也可以明确的指定函数中的this是什么类型，==this类型变量必须放在参数的首位==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj {</span><br><span class="line">    fn: (this: Obj, name: string) =&gt; void;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let obj: Obj = {</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let rab: Obj ={</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj.fn("兔兔"); // OK</span><br><span class="line">obj.fn.call(rab, "兔兔"); // OK</span><br><span class="line">obj.fn.call(window, "兔兔"); // Error: this 应该为 Obj 类型</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、参数"><a href="#1-3、参数" class="headerlink" title="1.3、参数"></a>1.3、参数</h3><p><code>可选参数</code></p><p>​    参数后加问号（？）注：==可选参数后面不允许再出现必需参数==</p><p><code>参数默认值</code></p><p>​    在函数定义时，参数内直接赋值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = 'Cat') {</span><br><span class="line">    return firstName + ' ' + lastName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <code>剩余参数</code></p><p>同js，用 … 表示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) {</span><br><span class="line">    items.forEach(function(item) {</span><br><span class="line">        array.push(item);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4、重载"><a href="#1-4、重载" class="headerlink" title="1.4、重载"></a>1.4、重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p><code>重载</code>的概念在学<code>JAVA</code>（<a href="https://link.juejin.cn/?target=https://www.runoob.com/java/java-override-overload.html"><code>JAVA中的重载</code></a>）的时候接触到的，<code>JS</code>是没有这个概念的，<code>TS</code>的重载感觉更应该称之为<code>函数签名重载</code>。因为最后函数实现的内部还是依赖判断类型来处理，前面的函数定义只是为了精确表达输入类型对应的输出类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string | void {</span><br><span class="line">    if (typeof x === 'number') {</span><br><span class="line">        return Number(x.toString().split('').reverse().join(''));</span><br><span class="line">    } else if (typeof x === 'string') {</span><br><span class="line">        return x.split('').reverse().join('');</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-7、-类"><a href="#1-7、-类" class="headerlink" title="1.7、 类"></a>1.7、 类</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>public  属性修饰符默认为<code>public</code>公共的，即类的属性、方法可以在外部访问</li><li>private  与<code>public</code>相对，私有修饰符，即类的属性、方法不可以在外部访问</li><li>protected 修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在<strong>派生类</strong>中仍然可以访问。注意，这里是<strong>派生类中</strong>，而不是<strong>实例、子类实例</strong>。</li><li>readonly 只读属性修饰符 构造函数中可以对只读属性进行修改  <img src="image-20210910114715199.png" alt="image-20210910114715199"></li><li>发生继承关系后类与类的叫法<img src="image-20210909200925647.png" alt="image-20210909200925647"></li></ul><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>我们也可以在类的内部方法上对参数使用<code>public、private、protected</code>修饰符，它的作用是可以更方便地让我们在一个地方定义并初始化一个成员。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Animal {</span><br><span class="line">    constructor(public name: string, private age: number, protected sex: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="接口实现类"><a href="#接口实现类" class="headerlink" title="接口实现类"></a>接口实现类</h3><p><code>TypeScript</code> 也能够用接口来明确的强制一个类去符合某种契约。类去实现接口，这里使用关键字<code>implements</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 一个类可以实现多个接口</span><br><span class="line">interface Age {</span><br><span class="line">  age: number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Title{</span><br><span class="line">  title: string;</span><br><span class="line">}</span><br><span class="line">class title implements Title, Age{</span><br><span class="line">  title: string = '兔兔';</span><br><span class="line">  age: number = 18;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用, 不允许被实例化。 不同于接口，抽象类可以包含成员的实现细节。 </p><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p><p><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department {</span><br><span class="line">    constructor(public name: string) {</span><br><span class="line">    }</span><br><span class="line">    printName(): void {</span><br><span class="line">        console.log('Department name: ' + this.name);</span><br><span class="line">    }</span><br><span class="line">    abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">}</span><br><span class="line">class AccountingDepartment extends Department {</span><br><span class="line">    constructor() {</span><br><span class="line">        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">    }</span><br><span class="line">    printMeeting(): void {</span><br><span class="line">        console.log('The Accounting Department meets each Monday at 10am.');</span><br><span class="line">    }</span><br><span class="line">    generateReports(): void {</span><br><span class="line">        console.log('Generating accounting reports...');</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let department: Department; // OK：允许创建一个对抽象类型的引用</span><br><span class="line">department = new Department(); // Error: 不能创建一个抽象类的实例</span><br><span class="line">department = new AccountingDepartment(); // OK：允许对一个抽象子类进行实例化和赋值</span><br><span class="line">department.printName(); // OK</span><br><span class="line">department.printMeeting(); // OK</span><br><span class="line">department.generateReports(); // Error: 方法在声明的抽象类中不存在</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-8、-泛型-lt-gt"><a href="#1-8、-泛型-lt-gt" class="headerlink" title="1.8、 泛型<>"></a>1.8、 泛型&lt;&gt;</h2><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王秋霞</title>
      <link href="/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/"/>
      <url>/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/</url>
      
        <content type="html"><![CDATA[<p>大爷今年六十花甲，穿着皮裤叼着雪茄，精神抖擞红光满颊，钞票大把塞满皮夹，欲求一女共度晚霞，诚心征婚就在当下，愿那女子年纪不大，做事温柔不像三八。唠唠家常说说闲话</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
