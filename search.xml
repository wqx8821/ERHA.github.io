<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端小白记</title>
      <link href="/2021/10/09/npm%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/10/09/npm%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1、nvm"><a href="#1、nvm" class="headerlink" title="1、nvm"></a>1、nvm</h2><p><strong>1.1 Mac 安装 nvm</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nvm-sh/nvm/blob/master/README.md</span><br></pre></td></tr></tbody></table></figure><p><strong>1.2 Windows 安装 nvm</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm-windows</span><br><span class="line">nodist</span><br></pre></td></tr></tbody></table></figure><h2 id="2、npm"><a href="#2、npm" class="headerlink" title="2、npm"></a>2、npm</h2><h4 id="2-1-全局安装package"><a href="#2-1-全局安装package" class="headerlink" title="2.1 全局安装package"></a>2.1 全局安装package</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install forever --global (-g)</span><br><span class="line">$ forever</span><br><span class="line">$ npm uninstall forever --global</span><br><span class="line">$ forever</span><br></pre></td></tr></tbody></table></figure><p><strong>全局安装包的目录</strong></p><ul><li><p>Mac</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/felix/.nvm/versions/node/nvm各个版本/bin/</span><br></pre></td></tr></tbody></table></figure></li><li><p>Windows</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\你的用户名\AppData\Roaming\npm\node_modules</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="2-2-本地安装package"><a href="#2-2-本地安装package" class="headerlink" title="2.2 本地安装package"></a>2.2 本地安装package</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/desktop</span><br><span class="line">$ mkdir gp-project</span><br><span class="line">$ cd gp-project</span><br><span class="line">$ npm install underscore</span><br><span class="line">$ npm list (ls)</span><br></pre></td></tr></tbody></table></figure><h4 id="2-3-package-json初始化"><a href="#2-3-package-json初始化" class="headerlink" title="2.3 package.json初始化"></a>2.3 package.json初始化</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">$ npm init -y</span><br><span class="line">$ ls</span><br><span class="line">$ cat package.json</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-使用package-json"><a href="#2-4-使用package-json" class="headerlink" title="2.4 使用package.json"></a>2.4 使用package.json</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ npm install underscore --save</span><br><span class="line">$ cat package.json</span><br><span class="line">$ npm install lodash --save-dev</span><br><span class="line">$ cat package.json</span><br><span class="line">$ rm -rf node_modules</span><br><span class="line">$ ls</span><br><span class="line">$ npm install</span><br><span class="line">$ npm uninstall underscore --save</span><br><span class="line">$ npm list | grep underscore</span><br><span class="line">$ cat package.json</span><br></pre></td></tr></tbody></table></figure><h4 id="2-5-安装指定版本的包"><a href="#2-5-安装指定版本的包" class="headerlink" title="2.5 安装指定版本的包"></a>2.5 安装指定版本的包</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">$ npm list</span><br><span class="line">$ npm info underscore</span><br><span class="line">$ npm view underscore versions</span><br><span class="line">$ npm install underscore@1.8.0</span><br><span class="line">$ npm list</span><br><span class="line">$ npm uninstall underscore</span><br><span class="line">$ npm list</span><br></pre></td></tr></tbody></table></figure><h4 id="2-6-更新本地安装的包"><a href="#2-6-更新本地安装的包" class="headerlink" title="2.6 更新本地安装的包"></a>2.6 更新本地安装的包</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore</span><br><span class="line">$ npm view underscore versions</span><br><span class="line">$ npm install underscore@1.4.4 --save-dev</span><br><span class="line">$ npm list | grep gulp</span><br><span class="line">$ npm outdated //~2.0.0表示patch, ^2.0.0表示minor * 表示xx最新版本</span><br><span class="line">$ npm list | grep gulp</span><br><span class="line">$ npm update</span><br></pre></td></tr></tbody></table></figure><h4 id="2-7-清除缓存"><a href="#2-7-清除缓存" class="headerlink" title="2.7 清除缓存"></a>2.7 清除缓存</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></tbody></table></figure><h4 id="2-8-上传自己的包"><a href="#2-8-上传自己的包" class="headerlink" title="2.8 上传自己的包"></a>2.8 上传自己的包</h4><h6 id="2-8-1-编写模块"><a href="#2-8-1-编写模块" class="headerlink" title="2.8.1 编写模块"></a>2.8.1 编写模块</h6><p>保存为index.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ </span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello World'</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-2-初始化包描述文件"><a href="#2-8-2-初始化包描述文件" class="headerlink" title="2.8.2 初始化包描述文件"></a>2.8.2 初始化包描述文件</h6><p>$ npm init package.json</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">{ </span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"gp19-npm"</span>, </span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.1"</span>, </span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"gp19 self module"</span>, </span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: { </span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"make test"</span> </span><br><span class="line">  }, </span><br><span class="line">  <span class="attr">"repository"</span>: { </span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Git"</span>, </span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git+https://github.com/lurongtao/gp19-npm.git"</span> </span><br><span class="line">  }, </span><br><span class="line">  <span class="attr">"keywords"</span>: [ </span><br><span class="line">    <span class="string">"demo"</span> </span><br><span class="line">  ], </span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"Felixlu"</span>, </span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>, </span><br><span class="line">  <span class="attr">"bugs"</span>: { </span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/lurongtao/gp19-npm/issues"</span> </span><br><span class="line">  }, </span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/lurongtao/gp19-npm#readme"</span>, </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-3-注册npm仓库账号"><a href="#2-8-3-注册npm仓库账号" class="headerlink" title="2.8.3 注册npm仓库账号"></a>2.8.3 注册npm仓库账号</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.npmjs.com 上面的账号</span><br><span class="line">felix_lurt/qqmko09ijn</span><br><span class="line">$ npm adduser</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-4-上传包"><a href="#2-8-4-上传包" class="headerlink" title="2.8.4 上传包"></a>2.8.4 上传包</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm publish</span><br></pre></td></tr></tbody></table></figure><p>坑：403 Forbidden</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看npm源：npm config get registry</span><br><span class="line">切换npm源方法一：npm config set registry http://registry.npmjs.org</span><br><span class="line">切换npm源方法二：nrm use npm</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-5-安装包"><a href="#2-8-5-安装包" class="headerlink" title="2.8.5 安装包"></a>2.8.5 安装包</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gp19-npm</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-6-卸载包"><a href="#2-8-6-卸载包" class="headerlink" title="2.8.6 卸载包"></a>2.8.6 卸载包</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看当前项目引用了哪些包 ：</span><br><span class="line">npm ls</span><br><span class="line">卸载包：</span><br><span class="line">npm unpublish --force</span><br></pre></td></tr></tbody></table></figure><h6 id="2-8-7-使用引入包"><a href="#2-8-7-使用引入包" class="headerlink" title="2.8.7 使用引入包"></a>2.8.7 使用引入包</h6><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = require('gp19-npm')</span><br><span class="line">hello.sayHello()</span><br></pre></td></tr></tbody></table></figure><h4 id="2-9-npm-脚本"><a href="#2-9-npm-脚本" class="headerlink" title="2.9 npm 脚本"></a>2.9 npm 脚本</h4><p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。</p><p><strong>一、什么是 npm 脚本？</strong></p><p>npm 允许在 package.json 文件里面，使用 scripts 字段定义脚本命令。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"scripts"</span>: {</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node build.js"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>二、执行顺序</strong></p><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><p>script1.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br></pre></td></tr></tbody></table></figure><p>script2.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"script1"</span>: <span class="string">"node script1.js"</span>,</span><br><span class="line">  <span class="string">"script2"</span>: <span class="string">"node script2.js"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果是并行执行（即同时的平行执行），可以使用 <code>&amp;</code> 符号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run script1 &amp; npm run script2</span><br></pre></td></tr></tbody></table></figure><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用 <code>&amp;&amp;</code> 符号。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run script1 &amp;&amp; npm run script2</span><br></pre></td></tr></tbody></table></figure><p><strong>三、简写形式</strong></p><p>常用的 npm 脚本简写形式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start 是 npm run start</span><br></pre></td></tr></tbody></table></figure><p><strong>四、变量</strong></p><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p><p>首先，通过 <code>npm_package_</code> 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。</p><blockquote><p>注意：一定要在 npm 脚本中运行（如：npm run view）才可以，直接在命令行中运行JS（如：node view.js）是拿不到值的</p></blockquote><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"foo"</span>, </span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.2.5"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: {</span><br><span class="line">    <span class="attr">"view"</span>: <span class="string">"node view.js"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回 1.2.5。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_name); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_version); <span class="comment">// 1.2.5</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用$npm_package_name 和 $npm_package_version 取到这两个值。</p><p>npm<em>package</em>前缀也支持嵌套的package.json字段。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"repository"</span>: {</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"xxx"</span></span><br><span class="line">},</span><br><span class="line">scripts: {</span><br><span class="line">  <span class="attr">"view"</span>: <span class="string">"echo $npm_package_repository_type"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。</p><p>下面是另外一个例子。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": {</span><br><span class="line">  "install": "foo.js"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，npm_package_scripts_install 变量的值等于 foo.js。</p><p>然后，npm 脚本还可以通过 npm<em>config</em> 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"view": "echo $npm_config_tag",</span><br></pre></td></tr></tbody></table></figure><p>注意，package.json 里面的 config 对象，可以被环境变量覆盖。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{ </span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"foo"</span>,</span><br><span class="line">  <span class="attr">"config"</span> : { <span class="attr">"port"</span> : <span class="string">"8080"</span> },</span><br><span class="line">  <span class="attr">"scripts"</span> : { <span class="attr">"start"</span> : <span class="string">"node server.js"</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，npm_package_config_port 变量返回的是 8080。这个值可以用下面的方法覆盖。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set foo:port 80</span><br></pre></td></tr></tbody></table></figure><p>最后，env命令可以列出所有环境变量。</p><p>“env”: “env”</p><h4 id="2-10-npm-安装-git-上发布的包"><a href="#2-10-npm-安装-git-上发布的包" class="headerlink" title="2.10 npm 安装 git 上发布的包"></a>2.10 npm 安装 git 上发布的包</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这样适合安装公司内部的git服务器上的项目</span><br><span class="line">npm install git+https://git@github.com:lurongtao/gp-project.git</span><br><span class="line"></span><br><span class="line"># 或者以ssh的方式</span><br><span class="line">npm install git+ssh://git@github.com:lurongtao/gp-project.git</span><br></pre></td></tr></tbody></table></figure><h4 id="2-11-cross-env-使用"><a href="#2-11-cross-env-使用" class="headerlink" title="2.11 cross-env 使用"></a>2.11 cross-env 使用</h4><h5 id="2-11-1-cross-env是什么"><a href="#2-11-1-cross-env是什么" class="headerlink" title="2.11.1 cross-env是什么"></a>2.11.1 cross-env是什么</h5><p>运行跨平台设置和使用环境变量的脚本</p><h5 id="2-11-2-出现原因"><a href="#2-11-2-出现原因" class="headerlink" title="2.11.2 出现原因"></a>2.11.2 出现原因</h5><p>当您使用 NODE_ENV=production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows 不支持 NODE_ENV=production 的设置方式。</p><h5 id="2-11-3-解决"><a href="#2-11-3-解决" class="headerlink" title="2.11.3 解决"></a>2.11.3 解决</h5><p>cross-env 使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包(cross-env)能够提供一个设置环境变量的 scripts，让你能够以 Unix 方式设置环境变量，然后在 Windows 上也能兼容运行。</p><h5 id="2-11-4-安装"><a href="#2-11-4-安装" class="headerlink" title="2.11.4 安装"></a>2.11.4 安装</h5><p>npm install –save-dev cross-env</p><h5 id="2-11-5-使用"><a href="#2-11-5-使用" class="headerlink" title="2.11.5 使用"></a>2.11.5 使用</h5><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"scripts"</span>: {</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config build/webpack.config.js"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>NODE_ENV环境变量将由 cross-env 设置 打印 process.env.NODE_ENV === ‘production’</p><h3 id="3、NRM-npm-registry-manager"><a href="#3、NRM-npm-registry-manager" class="headerlink" title="3、NRM: npm registry manager"></a>3、NRM: npm registry manager</h3><h4 id="3-1-手工切换源"><a href="#3-1-手工切换源" class="headerlink" title="3.1 手工切换源"></a>3.1 手工切换源</h4><h5 id="3-1-1-查看当前源"><a href="#3-1-1-查看当前源" class="headerlink" title="3.1.1 查看当前源"></a>3.1.1 查看当前源</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></tbody></table></figure><h5 id="3-1-2-切换淘宝源"><a href="#3-1-2-切换淘宝源" class="headerlink" title="3.1.2 切换淘宝源"></a>3.1.2 切换淘宝源</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2-NRM-管理源"><a href="#3-2-NRM-管理源" class="headerlink" title="3.2 NRM 管理源"></a>3.2 NRM 管理源</h4><p>NRM (npm registry manager)是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换。</p><h5 id="3-2-1-安装-nrm"><a href="#3-2-1-安装-nrm" class="headerlink" title="3.2.1 安装 nrm"></a>3.2.1 安装 nrm</h5><p>在命令行执行命令，npm install -g nrm，全局安装nrm。</p><h5 id="3-2-2-使用-nrm"><a href="#3-2-2-使用-nrm" class="headerlink" title="3.2.2 使用 nrm"></a>3.2.2 使用 nrm</h5><p>执行命令 nrm ls 查看可选的源。 其中，带*的是当前使用的源，上面的输出表明当前源是官方源。</p><h5 id="3-2-3-切换-nrm"><a href="#3-2-3-切换-nrm" class="headerlink" title="3.2.3 切换 nrm"></a>3.2.3 切换 nrm</h5><p>如果要切换到taobao源，执行命令nrm use taobao。</p><h5 id="3-2-4-测试速度"><a href="#3-2-4-测试速度" class="headerlink" title="3.2.4 测试速度"></a>3.2.4 测试速度</h5><p>你还可以通过 nrm test 测试相应源的响应时间。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm test</span><br></pre></td></tr></tbody></table></figure><h3 id="4、NPX-npm-package-extention"><a href="#4、NPX-npm-package-extention" class="headerlink" title="4、NPX: npm package extention"></a>4、NPX: npm package extention</h3><p>npm 从5.2版开始，增加了 npx 命令。它有很多用处，本文介绍该命令的主要使用场景。</p><p>Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g npx</span><br></pre></td></tr></tbody></table></figure><h4 id="4-1-调用项目安装的模块"><a href="#4-1-调用项目安装的模块" class="headerlink" title="4.1 调用项目安装的模块"></a>4.1 调用项目安装的模块</h4><p>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了Mocha。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -D mocha</span><br></pre></td></tr></tbody></table></figure><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的scripts字段里面，如果想在命令行下调用，必须像下面这样。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 项目的根目录下执行</span><br><span class="line">$ node-modules/.bin/mocha --version</span><br></pre></td></tr></tbody></table></figure><p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx mocha --version</span><br></pre></td></tr></tbody></table></figure><p>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。</p><p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 等同于 ls</span><br><span class="line">$ npx ls</span><br></pre></td></tr></tbody></table></figure><p>注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。</p><h4 id="4-2-避免全局安装模块"><a href="#4-2-避免全局安装模块" class="headerlink" title="4.2 避免全局安装模块"></a>4.2 避免全局安装模块</h4><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app 这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app my-react-app</span><br></pre></td></tr></tbody></table></figure><p>上面代码运行时，npx 将 create-react-app 下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 create-react-app。</p><p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx http-server</span><br></pre></td></tr></tbody></table></figure><h4 id="4-3-–no-install-参数和-–ignore-existing-参数"><a href="#4-3-–no-install-参数和-–ignore-existing-参数" class="headerlink" title="4.3 –no-install 参数和 –ignore-existing 参数"></a>4.3 –no-install 参数和 –ignore-existing 参数</h4><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --no-install http-server</span><br></pre></td></tr></tbody></table></figure><p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经安装了http-server，但还是想使用远程模块，就用这个参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx --ignore-existing http-server</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端小白记</title>
      <link href="/2021/09/29/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/29/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML篇"><a href="#HTML篇" class="headerlink" title="HTML篇"></a>HTML篇</h1><p>+/*</p><h3 id="1-html概念"><a href="#1-html概念" class="headerlink" title="1.html概念/"></a>1.html概念/</h3><ul><li>html全称HyperText Markup Language,翻译为超文本标记语言,它不是一种编程语言,是一种描述性的标记语言,用于描述超文本内容的显示方式,比如字体,颜色,大小等</li><li>超文本 : 音频,视频,图片等称为超文本</li><li>标记:  &lt;一个英文字母或者单词&gt; 这种类型称之为标记</li><li><strong>作用</strong> : html是负责描述文档语义的语言</li><li><strong>注意</strong> : html语言不是编程语言(有编译过程),而是一个标记语言(没有编译过程),HTML页面直接由浏览器解析执行</li><li>html是一个纯文本文件(也就是txt文件改名而成),用一些标签来描述文字的语义,这些标签在浏览器中是看不到的,所以称为超文本,所以就是超文本语言了</li></ul><h3 id="2-html的网络术语"><a href="#2-html的网络术语" class="headerlink" title="2.html的网络术语"></a>2.html的网络术语</h3><ul><li>网页 ; 由各种标记组成的一个页面就是网页</li><li>主页(首页) ; 一个网站的起始页面或者导航页面</li><li>标记: &lt; p &gt; 称为开始标记,&lt;/ p&gt;称为结束标记,也叫标签,每个标签都规定好了特殊的含义</li><li>元素: 标记之间的内容就叫做元素</li><li>属性,标记中对没一个标签所做的辅助信息</li></ul><h3 id="3-html规范"><a href="#3-html规范" class="headerlink" title="3.html规范"></a>3.html规范</h3><ul><li>所有的标记都要正确的嵌套,不能交叉嵌套,就是一个标记的开始标记和结束标记之间不能存在单独的其他开始标记或结束标记,也就是不能交叉嵌套</li><li>所有标记必须小写</li><li>所有标记必须关闭<ul><li>双边标记 : &lt; span &gt;&lt; /span &gt;</li><li>单边标记 : <code>&lt;br&gt;</code> 转成 <code>&lt;br /&gt;</code> <code>&lt;hr&gt;</code> 转成 <code>&lt;hr /&gt;</code>，还有<code>&lt;img src=“URL” /&gt;</code></li><li>所有属性必须加引号&lt; h1 id = “head” &gt; &lt; /h1 &gt;</li><li>所有属性必须有值</li></ul></li></ul><h3 id="4-htmL的基本语法特征"><a href="#4-htmL的基本语法特征" class="headerlink" title="4.htmL的基本语法特征"></a>4.htmL的基本语法特征</h3><ul><li>对换行不敏感,对tab不敏感<ul><li>html只在乎标签的嵌套结构,嵌套的关系,换行和tab对页面结构不影响</li></ul></li><li>空白折叠现象<ul><li>html中所有的文字中间,如果有空格,换行,tab都将被折叠为一个空格显示</li></ul></li><li>标签严格封闭</li></ul><h3 id="5-html结构"><a href="#5-html结构" class="headerlink" title="5.html结构"></a>5.html结构</h3><ul><li><p>新建html文件,输入html:5 或者 ! 按下tab键后,自动生成默认的代码,如下</p><ul><li><p>```html</p>    <meta charset="UTF-8">    <title>Document</title>    <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 文档声明头</span><br><span class="line"></span><br><span class="line">  - 任何的标准的html页面,第一行一定是一个以&lt; !DOCTYPE html &gt;开头的一行,这就是文档声明头,DocType Declaration,简称DTD,此标签可以告知浏览器文档使用哪种html或xhtml规范</span><br><span class="line"></span><br><span class="line">- 头标签</span><br><span class="line"></span><br><span class="line">  - head标签都放在头部分之间,这里包含了&lt; title &gt; ,&lt; meta &gt;,&lt; link &gt; ,&lt; style &gt;</span><br><span class="line"></span><br><span class="line">    - &lt; title &gt; :指整个网页的标题,显示在浏览器的最上边</span><br><span class="line"></span><br><span class="line">      - 主要是告诉用户和搜索引擎这个网页的主要内容是什么,搜索引擎可以通过网页标题,迅速的判断出当前网页的主题</span><br><span class="line"></span><br><span class="line">    - &lt; meta &gt; :提供有关页面的基本信息</span><br><span class="line"></span><br><span class="line">      - 严肃可提供有关页面的元信息(mata-information),针对搜索引擎和更新频度的关键词</span><br><span class="line"></span><br><span class="line">      - 提供的信息用户不可见,分别有两个属性</span><br><span class="line"></span><br><span class="line">        - http_equiv属性</span><br><span class="line"></span><br><span class="line">          - 它用来向浏览器传达一些有用的信息,帮助浏览器正确的显示网页的内容,与之对应的属性值为content,content中的内容就是各个参数的变量值</span><br><span class="line"></span><br><span class="line">          - ```html</span><br><span class="line">            &lt;!--重定向 2秒后跳转到对应的网址，注意分号--&gt;</span><br><span class="line">            &lt;meta http-equiv="refresh" content="2;URL=http://www.luffycity.com"&gt;</span><br><span class="line">            &lt;!--指定文档的内容类型和编码类型 --&gt;</span><br><span class="line">            &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8" /&gt;</span><br><span class="line">            &lt;!--告诉IE浏览器以最高级模式渲染当前网页--&gt;</span><br></pre></td></tr></tbody></table></figure><pre><code><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;</span><br></pre></td></tr></tbody></table></figure></code></pre><ul><li><p>name属性</p><ul><li><p>主要用于页面的关键字描述,写给搜索引擎看的,关键字之间可以用逗号隔开,与之对应的属性值为content,content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的</p></li><li><p>```html</p><meta name="Keywords" content="网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 这些关键词就是告诉搜索引擎,这个网页是干嘛的,能够提高搜索命中率,让别人能都通过搜索引擎搜索到</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;meta name="Description" content="网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。" /&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>只要设置Description页面描述,那么百度搜索结果,就能显示这些语句,这个技术叫做SEO(search engine optimization,搜索引擎优化</li></ul></li><li><p>```html</p><meta name="viewport" content="width=device-width, initial-scale=1"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">          - 上面这个标签,是让我们网页支持移动端,移动设备优先</span><br><span class="line"></span><br><span class="line">    - &lt; link &gt; :定义文档与外部资源的关系</span><br><span class="line"></span><br><span class="line">    - &lt; style &gt; : 定义内部样式表与网页的关系</span><br><span class="line"></span><br><span class="line">- html颜色显示</span><br><span class="line"></span><br><span class="line">  - 纯单词表示:red,green,blue,orange,gray等</span><br><span class="line">  - 十进制表示: rgb(255,0,0)</span><br><span class="line">  - 16进制表示 : #FF0000</span><br><span class="line"></span><br><span class="line">### 6.html标签</span><br><span class="line"></span><br><span class="line">- 标签分类</span><br><span class="line">- ![1565165927495](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1565165927495.png)</span><br><span class="line">  - html标签又叫html元素,它分为块级元素和内联元素(行内元素),都是html规范中的概念</span><br><span class="line">- 块级元素</span><br><span class="line"></span><br><span class="line">  - 块级元素是指本身属性为display:block的元素,因为它自身的特点我们通常使用块级元素来进行大布局(大结构)的搭建</span><br><span class="line">    - 特点</span><br><span class="line">    - 独占一行,每个块级元素都会从新的一行重新开始,从上到下排布</span><br><span class="line">      - 可以和直接控制宽度,高度以及盒子模型相关的css属性</span><br><span class="line">      - 在不设置宽度的情况下,块级元素的宽度是它父级元素内容的宽度</span><br><span class="line">      - 在不设置高度的情况下,块级元素的高度是它本身内容的高度</span><br><span class="line">  - 内联元素</span><br><span class="line"></span><br><span class="line">    - ![1565165950629](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1565165950629.png)</span><br><span class="line">  - 内联元素是指本身属性为display:inlline;的元素,他因为自身的特点,我们通常使用内联元素来进行文字,小图标(小结构)的搭建</span><br><span class="line">    - 特点</span><br><span class="line">  - 和其他内联元素从左到右一行显示</span><br><span class="line">    - 不能直接控制宽度,高度以及盒子模型的相关css属性,但是直接设置内外边距的左右值是可以的</span><br><span class="line">    - 内联元素的宽度是由本身内容的大小决定的</span><br><span class="line">      - 内联元素只能容纳文本或者其他内联元素(不要再内联元素中嵌套块级元素)</span><br><span class="line">- 文本及和容器级</span><br><span class="line">  - 标签可分为文本级和容器级</span><br><span class="line">    - 文本级标签:p,span,a,b,i,u,em</span><br><span class="line">    - 容器级 : dic,h系列,li,dt,dd</span><br><span class="line">  - 文本级标签的意思是标签中只可以放文本,不可以放其他内容,出了p之外,所有的文本级标签都是行内元素,p是个文本及,但是个块级元素</span><br><span class="line">  - p里面只能放文本,图片,表单元素,p里面不能放h和ul,p里面也不能放p</span><br><span class="line"></span><br><span class="line">### 7.html中的特殊字符</span><br><span class="line"></span><br><span class="line">- `&amp;nbsp;`：空格 （non-breaking spacing，不断打空格）</span><br><span class="line">- `&amp;lt;`：小于号（less than）</span><br><span class="line">- `&amp;gt;`：大于号（greater than）</span><br><span class="line">- `&amp;amp;`：符号`&amp;`</span><br><span class="line">- `&amp;quot;`：双引号</span><br><span class="line">- `&amp;apos;`：单引号</span><br><span class="line">- `&amp;copy;`：版权`©`</span><br><span class="line">- `&amp;trade;`：商标`™`</span><br><span class="line"></span><br><span class="line">## HTML块级元素</span><br><span class="line"></span><br><span class="line">### 1.h1 - h6</span><br><span class="line"></span><br><span class="line">- 标题使用&lt; h1 &gt; 至 &lt; h6 &gt;标签进行定义.具有align属性,属性值可以使left.center,right</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">      &lt;h1 align="right"&gt;一级标题&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;二级标题&lt;/h2&gt;</span><br><span class="line">      &lt;h3&gt;三级标题&lt;/h3&gt;</span><br><span class="line">      &lt;h4&gt;四级标题&lt;/h4&gt;</span><br><span class="line">      &lt;h5&gt;五级标题&lt;/h5&gt;</span><br><span class="line">      &lt;h6&gt;六级标题&lt;/h6&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><ul><li><p>列表分为三种,有序列表ol,无序列表和定义类表dl,其中ol和ul必须结合li标签使用,而dl则必须结合dt,dd使用</p></li><li><p>ol ordered list    有序列表</p><ul><li>li list item，列表项</li></ul></li><li><p>ul unordered list 无序列表</p><ul><li>li list item，列表项</li></ul></li><li><p>dl definition list  定义列表</p></li><li><ul><li><code>&lt;dt&gt;</code>：definition title 列表的标题，这个标签是必须的</li><li><code>&lt;dd&gt;</code>：definition description 列表的列表项，如果不需要它，可以不加</li></ul></li><li><p>li不能单独存在,必须包裹在ul或者dl中</p></li></ul><h3 id="3-排版标签"><a href="#3-排版标签" class="headerlink" title="3.排版标签"></a>3.排版标签</h3><ul><li>段落标签<p></p></li><li>属性<ul><li>align = “属性值” : 对齐方式包括left,right,center</li><li>HTMl是分等级的,html将所有的标签分为两种<ul><li>文本级标签,p,span,a,b,i,u,em.文本级标签里只能放文字,图片,表单元素</li><li>容器级标签: div,h系列,li,dt,dd,容器级标签里可以放任何东西</li></ul></li></ul></li><li>div<ul><li>div和span是非常重要的标签1,div的语义是division”分割”</li><li>div : 把标签中的内容作为一个块儿来对待,必须单独占一行</li><li>div标签的属性:<ul><li>align = “属性值” ; 设置块儿的位置,属性值可以选择 ; left,right,center</li></ul></li><li>单独在网页中插入这个元素,不会对页面产生影响,这两个元素是撞门为定义css样式而生的,或者说,DIV+CSS可以实现各种样式,</li><li>div+css,div标签负责布局,负责结构,负责分块,css负责样式</li></ul></li></ul><h3 id="4-hr"><a href="#4-hr" class="headerlink" title="4.hr"></a>4.hr</h3><ul><li>水平分割线,可以在视觉上将文档分隔成各个部分</li></ul><h3 id="5-内容居中标签-lt-center-gt"><a href="#5-内容居中标签-lt-center-gt" class="headerlink" title="5.内容居中标签< center >"></a>5.内容居中标签&lt; center &gt;</h3><ul><li>此时center代表的是一个标签,不是一个属性值,只要是在这个标签里面内容,都会居于浏览器的中间</li><li>在H5中不建议使用center标签</li></ul><h3 id="6-预定义-预格式化-标签-lt-pre-gt"><a href="#6-预定义-预格式化-标签-lt-pre-gt" class="headerlink" title="6.预定义(预格式化)标签< pre >"></a>6.预定义(预格式化)标签&lt; pre &gt;</h3><ul><li>含义:将保留其中所有的空白字符(空格,换行符),原封不动的输出结果(高速浏览器不要忽略空格和空行)</li><li>说明: 真正排网页的过程中,&lt; pre &gt; 标签基本不用,但在PHP中用于打印一个数组时使用</li></ul><h3 id="7-table"><a href="#7-table" class="headerlink" title="7.table"></a>7.table</h3><ul><li><p>一个 表格标签用&lt; table &gt;表示,由&lt; table &gt; 由表头&lt; thead &gt;和表格内容&lt; tbody &gt;组成的.其中每一行是&lt; tr &gt;,每一格是由, &lt; td &gt;组成的</p></li><li><p>表格属性</p><ul><li>boder:边框&lt;像素为单位</li><li>style = “boder-collapse:collapse:”  :  单元格的线和表格边框线合并</li><li>width : 宽度,像素为单位</li><li>height : 高度,像素为单位</li><li>bordercolor : 表格的边框颜色</li><li>align:表格的水平对齐方式,属性值可以填 ;left right center<ul><li>这里的是水平对齐方式,不是表格内容的对齐方式,要想设置表格内容对齐方式,需要在&lt; td &gt;中添加</li></ul></li><li>cellpadding : 单元格内容到边的距离,像素为单位,默认情况下,文字是紧挨着左边那条线的,即默认情况下的值为0,默认是以到四边的左边那条线,如果设置属性dir = “rtl”,那么就是指内容到右边的那条线的距离</li><li>cellspacing : 单元格之间的距离(外边框),</li><li>bgcolor = “#99ccff” : 表格的背景颜色</li><li>backgrand = “路径src /“ : 背景图片<ul><li>图片的优先级大于颜色的优先级</li></ul></li></ul><h3 id="8-table行"><a href="#8-table行" class="headerlink" title="8.table行"></a>8.table行</h3><ul><li>dir ; 公有属性,设置这一行单元格的排列方式,可以取值,ltr : 从左到右(left 头right),rtl反之</li><li>bgcolor : 这一行单元格的背景色,没有backgrand属性,要想设置只能通过css实现</li><li>height : 一行的高度</li><li>align = “center” : 一行的内容水平居中显示,取值 : left ,center ,right</li><li>valign =”center” ;一行的内容垂直居中,取值 : top,middle,botto</li></ul><h3 id="9-table-单元格"><a href="#9-table-单元格" class="headerlink" title="9.table 单元格"></a>9.table 单元格</h3><ul><li>属性<ul><li>align ; 内容的横向对齐方式,left right center</li><li>valign : 纵向,top,middle bottom</li><li>width 绝对值或者相对值(%)</li><li>height : 单元格高低</li><li>bgcolor : 单元格背景色</li><li>&lt; th &gt;:加粗的单元格,相当于&lt; td &gt; +  &lt; b &gt;<ul><li>属性通&lt; td &gt; 标签</li></ul></li><li>&lt; caption &gt; 表格的标题,使用时和tr标签并列</li><li>&lt; thead &gt; ,&lt; thead &gt;,&lt; tfoot &gt;,决定表格的显示顺序,默认按照代码从上到下显示<ul><li>在表格内容非常大的时候,设置这三个属性属性可以变获取边显示,如果不写,则必须等表格的内容全部从服务器获取完成才能显示</li></ul></li></ul></li><li>操作<ul><li>colspan : 横向合并,colspan = “2”表示在当前单元格在水平方向上要占据两个单元的位置</li><li>rowspan ; 纵向合并,例如rowspan = “2”,表示在当前单元格在垂直方向上要占据两个单元格的位置</li></ul></li></ul></li></ul><h3 id="8-表单"><a href="#8-表单" class="headerlink" title="8.表单"></a>8.表单</h3><ul><li><p>表单功能</p><ul><li>表单用于向服务器传输数据,从而实现用户与web服务器的交互</li><li>表单能够包含input系列标签,比如文本字段,复选框,单选框,提交按钮等等</li><li>表单还能把汗textrea ,select,fledset,label标签</li></ul></li><li><p>表单属性</p><ul><li><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accept-charset</td><td>规定在被提交表单中使用的字符集（默认：页面字符集）。</td></tr><tr><td>action</td><td>规定向何处提交表单的地址（URL）（提交页面）。</td></tr><tr><td>autocomplete</td><td>规定浏览器应该自动完成表单（默认：开启）。</td></tr><tr><td>enctype</td><td>规定被提交数据的编码（默认：url-encoded）。</td></tr><tr><td>method</td><td>规定在提交表单时所用的 HTTP 方法（默认：GET）。</td></tr><tr><td>name</td><td>规定识别表单的名称（对于 DOM 使用：document.forms.name）。</td></tr><tr><td>novalidate</td><td>规定浏览器不验证表单。</td></tr><tr><td>target</td><td>规定 action 属性中地址的目标（默认：_self）。</td></tr></tbody></table></li></ul></li><li><p>表单元素</p><ul><li>基本概念<ul><li>html表单是html元素中较为复杂的部分,表单往往和脚本,动态页面,数据处理等功能相结合</li><li>一般用收集用户的输入信息</li><li>表单工作原理:<ul><li>访问者在浏览有表单的网页时,可填写必须的信息,然后按某个按钮提交,这些信息通过intert传送到服务器上</li><li>服务器专门的程序对这些数据进行处理,有错误信息会返回错误信息,并要求纠正错误,当数据完整无误后,服务器反馈一个输入完成的信息</li></ul></li></ul></li></ul></li><li><p>属性</p><ul><li><p>name:表单的名称,用于js来操作或控制表单时使用,就想分组一样,可以重复</p></li><li><p>id: 表单的名称,用于js来操作或控制表单时使用,html中的唯一标识,不可重复</p></li><li><p>acton ; 指定表单数据的处理程序,一般是PHP,如action = “login.php”</p></li><li><p>method: 表单数据的提交方式,一般取值get(默认)和post</p><ul><li>get 和 post 的区别<ul><li>get将表单数据以”name=value”的形式追加到action指定的处理程序后面,两者之间用”?”隔开,每一个表单的”name=value”间用”&amp;”隔开<ul><li>特点 : 只适合提交少量的信息,并不天安全(不要提交敏感数据),提交的类型只限于</li></ul></li><li>post将表单数据直接发送(隐藏)到action指定的处理程序,post发送的数据不可见,action指定的处理程序可以获取到表单数据<ul><li>特点 : 可以提交海量信息,相对来说比较安全,提交的数据格式是多样的(word,Excel,rar,img等)</li></ul></li></ul></li></ul></li><li><p>Enctype</p><ul><li>表单数据的编码方式(加密方式)取值可以是 : application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</li><li>application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</li></ul></li><li><p>&lt; inpt &gt; 输入标签(文本框)(内联标签)</p><ul><li><table><thead><tr><th>type属性值</th><th>表现形式</th><th>对应代码</th></tr></thead><tbody><tr><td>text</td><td>单行输入文本</td><td>&lt;input type=text” /&gt;</td></tr><tr><td>password</td><td>密码输入框（不显示明文）</td><td><input type="password"></td></tr><tr><td>date</td><td>日期输入框</td><td><input type="date"></td></tr><tr><td>checkbox</td><td>复选框</td><td><input type="checkbox" checked="checked" name="x"></td></tr><tr><td>radio</td><td>单选框</td><td><input type="radio" name="x"></td></tr><tr><td>submit</td><td>提交按钮</td><td><input type="submit" value="提交"> #发送浏览器上输入标签中的内容，配合form表单使用，页面会刷新</td></tr><tr><td>reset</td><td>重置按钮</td><td><input type="reset" value="重置">  #页面不会刷新，将所有输入的内容清空</td></tr><tr><td>button</td><td>普通按钮</td><td><input type="button" value="普通按钮"></td></tr><tr><td>hidden</td><td>隐藏输入框</td><td><input type="hidden"></td></tr><tr><td>file</td><td>文本选择框</td><td><input type="file"></td></tr></tbody></table></li><li><p>type = “属性值”,文本类型,属性值可以是:</p><ul><li>text(默认)</li><li>password ; 密码类型</li><li>radio: 单选按钮,名字相同的按钮作为一组进行单选(单选按钮,天生是不能互斥的,如果想要互斥,必须要有相同的name属性,</li><li>checkbox : 多选按钮,名字相同的按钮作为一组选择</li><li>checked ; 将单选或者多选按钮默认处于选中状态</li><li>hidden : 隐藏框,在表单中包含不希望用户看见的信息</li><li>button ; 普通的按钮,结合js代码进行使用</li><li>submit ; 提交按钮,将当前表单数据给服务器或者其他程序进行处理</li><li>reset : 重置按钮,清空当前表单的内容,并设置为最初的默认值</li><li>image : 图片按钮,和提交按钮一样的功能,不过图片按钮可以显示图片</li><li>file: 文本选择框<ul><li>可配合js来实现验证,对上传的文件进行安全的检查,一是扩展名的检查,二是文件数据的检查</li></ul></li></ul></li><li><p>value = “内容” 文本框中默认的内容</p></li><li><p>size = “50” : 表示文本框内可以显示五十个字符,一个英文或者一个中文都算一个字符</p></li><li><p>readonly : 文本框只读,不能编辑,光标进不去,属性值可以不写</p></li></ul></li><li><p>&lt; select &gt; :下拉列表标签(内联标签)</p><ul><li>&lt; select &gt; 标签里的每一项都用&lt; option &gt; 表示,select 就是选择,option” 选项”</li><li>select 标签和ul,ol,dl一样,都是组标签</li><li>属性<ul><li>multiple : 可以对下拉列表中的选项进行多选,没有属性值,ctrl+鼠标点选</li><li>size = “3”,如果属性值大于1,则列表为滚动视图,默认属性值为1,即下拉列表</li></ul></li></ul></li><li><p>&lt; option &gt;标签的属性</p><ul><li>selected : 预选中,没有属性值</li></ul></li><li><p>&lt; textarea &gt;标签:多行文本输入框(内联标签)</p><ul><li>text就是文本,area就是区域</li><li>属性<ul><li>value : 提交给服务器的值</li><li>rows = “4” :指定文本区域的行数</li><li>cols = “20” :制定文本区域的列数</li><li>readonly: 只读</li></ul></li></ul></li><li><p>&lt; label&gt; 标签(内联标签)</p><ul><li><p>单选复选框只有点击小圆圈才能选中,可以用label解决,</p><ul><li>```html<br>input type=”radio” name=”sex” id=”nan” /&gt; <label for="nan">男</label><br><input type="radio" name="sex" id="nv"> <label for="nv">女</label><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HTML内联元素</span><br><span class="line"></span><br><span class="line">### 1.字体标签</span><br><span class="line"></span><br><span class="line">- 粗标签&lt; b &gt;或&lt; strong &gt; (已废弃)</span><br><span class="line">- 斜体标记&lt; I &gt; 或&lt; em &gt;(已废弃)</span><br><span class="line">- 上标 &lt; sup &gt; 下标 &lt; sub &gt; </span><br><span class="line">- 下划线标记&lt; u &gt; 中划线标记&lt; s &gt; (已废弃) 和,&lt; del &gt;</span><br><span class="line"></span><br><span class="line">### 2.排班标签</span><br><span class="line"></span><br><span class="line">### 3超链接</span><br><span class="line"></span><br><span class="line">- 外部链接</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;a href="new.html"&gt;点击进入到新网页&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>也可直接点击链接进入</p></li><li><p>```html<br><a href="http://www.baidu.com" target="_blank">进入百度</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 锚链接</span><br><span class="line"></span><br><span class="line">  - 给指定的超链接起一个名字,作用是在本页面或者其他页面的不同位置进行跳转,像回到顶部按钮一样,#top</span><br><span class="line"></span><br><span class="line">- 邮件链接</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;a href="mailto:zhaoxu@tedu.cn"&gt;联系我们&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>特殊链接 </p><ul><li><p>返回页面顶部</p><ul><li><p>```html<br><a href="#">跳转到顶部</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 与js有关</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;a href="#"&gt;跳转到顶部&lt;/a&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>javascrip:;表示什么都不执行,这样点击&lt; a &gt;没有任何响应</p></li><li><p>javastrip: 是表示在触发&lt; a &gt; 的时候执行一段JavaScript的代码</p></li></ul></li></ul></li><li><p>超链接的属性</p><ul><li>href : 目标URL</li><li>title : 悬停文本</li><li>name : 主要用于设置一个锚点的名称</li><li>target : 告诉浏览器用什么方式来打开目标页面<ul><li>-self :同一网页</li><li>-blank: 在新的窗口打开</li><li>-parent : 在父窗口中显示</li><li>-top ; 在顶级窗口显示</li></ul></li></ul></li></ul><h3 id="4-图片标签-lt-img-gt"><a href="#4-图片标签-lt-img-gt" class="headerlink" title="4.图片标签< img />"></a>4.图片标签&lt; img /&gt;</h3><ul><li>img : 代表的就是一张图片,且是单边标记,它是自封闭标签,也称为单标签</li><li>能插入的图片类型<ul><li>能插入: jpg(jpeg),gif,png,bmp</li><li>不能插入: psd,ai</li><li>html页面不是直接插入图片,而是插入图片的引入地址,所以要把图片上传到服务器上</li></ul></li><li>src属性:图片的相对路径和绝对路径<ul><li>相对路径:   . 代表当前目录,   ..代表父路径</li><li>绝对路径: 盘符开始的绝对路径和网络路径</li></ul></li><li>img标签常用属性<ul><li>width,height,宽度高度</li><li>title,提示性文本,也就是鼠标悬停时显示的文本</li><li>align : 指图片的对齐方式,属性值可以是left,center,right</li><li>alt : 当图片显示不出来的时候,代替图片显示的内容,</li><li>src属性,点击图片跳转到相应的链接</li></ul></li></ul><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><h3 id="1-为什么学习css"><a href="#1-为什么学习css" class="headerlink" title="1.为什么学习css"></a>1.为什么学习css</h3><ul><li>​    html的缺陷<ul><li>不能够适应多种设备</li><li>要求浏览器必须足够智能足够庞大</li><li>数据和显示没有分开</li><li>功能不够强大</li></ul></li><li>css的优点<ul><li>使数据和显示分开</li><li>降低网络的流量</li><li>使整个网站视觉效果一致</li><li>使开发效率提高了(耦合性降低,一个负责写html,一个负责写css)</li></ul></li></ul><h3 id="2-css的引入方法"><a href="#2-css的引入方法" class="headerlink" title="2.css的引入方法"></a>2.css的引入方法</h3><ul><li><p>行内样式</p><ul><li>```html<div>    <p style="color: green">我是一个段落</p></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 接样式</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">        /*写我们的css代码*/     </span><br><span class="line">        span{</span><br><span class="line">        color: yellow;</span><br><span class="line">        }</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>外接样式-链接式</p><ul><li>```html<link rel="stylesheet" href="./index.css">html<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 外接样式-导入式</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">            @import url('./index.css');</span><br><span class="line">    &lt;/style&gt; </span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="3-css选择器"><a href="#3-css选择器" class="headerlink" title="3.css选择器"></a>3.css选择器</h3><ul><li><p>标签选择器(标签名)</p><ul><li>标签选择器可以选中所有的标签元素,比如div,ul,li,p等,不管标签隐藏的多深,都能选中所有的标签,</li></ul></li><li><p>类选择器</p><ul><li><p>类就是class,任何的标签都可以加类,类可以重复,适于归类的概念,同一个标签中可以携带多个类,用空格隔开</p><ul><li>```<br>.lv{<pre><code> color: green;</code></pre> }<br> .big{<pre><code> font-size: 40px;</code></pre> }<br> .line{<pre><code>text-decoration: underline;</code></pre>  }<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;!-- 公共类    共有的属性 --&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;p class="lv big"&gt;段落1&lt;/p&gt;</span><br><span class="line">           &lt;p class="lv line"&gt;段落2&lt;/p&gt;</span><br><span class="line">           &lt;p class="line big"&gt;段落3&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>id选择器</p><ul><li><p>同一个页面中id不能重复,任何的标签都可以设置id,id命名规范,要以数字,下划线大小写严格区分,aa和AA就是两个不一样的属性值</p></li><li><p>css</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#box{</span><br><span class="line">    background:green;</span><br><span class="line">}</span><br><span class="line">            </span><br><span class="line">#s1{</span><br><span class="line">    color: red;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#s2{</span><br><span class="line">    font-size: 30px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>html</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>娃哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s1"</span>&gt;</span>爽歪歪<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s2"</span>&gt;</span>QQ星<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>高级选择器</p><ul><li><p>后代选择器</p><ul><li><p>用空格表示后代选择器</p></li><li><p>```html<br>.container p{</p><pre><code>color: red;        </code></pre><p>}<br>.container .item p{</p><pre><code>color: yellow;</code></pre><p>}</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 子代选择器</span><br><span class="line"></span><br><span class="line">  - 用&gt;表示子代选择器,比如div&gt;p,仅仅表示的是当前div元素选中的子代(不包括孙子)元素P</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    .container&gt;p{</span><br><span class="line">         color: yellowgreen;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>并集选择器</p><ul><li>```html<br>/<em>并集选择器</em>/<br>h3,a{<pre><code>color: #008000;text-decoration: none;            </code></pre>}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td {</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0</span><br><span class="line">     }</span><br><span class="line">  /*使用此并集选择器选中页面中所有的标签，页面布局的时候会使用*/</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>交集选择器</p><ul><li><p>使用 . 表示交集选择器,第一个标签名必须是标签选择器,第二个标签必须是类选择器,语法:div.active,比如有一个&lt; h4 class=’active’ &gt;&lt; h4&gt; 这样的标签,name它表示两者选中之后元素共有的特性</p></li><li><p>```html<br>h4{</p><pre><code>width: 100px;font-size: 14px;</code></pre><p>}<br>.active{</p><pre><code>color: red;text-decoration: underline;</code></pre><p>}<br>/* 交集选择器 */<br>h4.active{</p><pre><code>background: #00BFFF;</code></pre><p>}</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 更多选择器</span><br><span class="line"></span><br><span class="line">  - 伪类选择器</span><br><span class="line"></span><br><span class="line">    - 伪类悬着器一般会使用在超链接a标签中</span><br><span class="line"></span><br><span class="line">      ```html</span><br><span class="line">            /*link表示没有被访问的a标签的样式*/</span><br><span class="line">              .box ul li.item1 a:link{</span><br><span class="line">                  </span><br><span class="line">                  color: #666;</span><br><span class="line">              }</span><br><span class="line">              /*visited表示访问过后的a标签的样式*/</span><br><span class="line">              .box ul li.item2 a:visited{</span><br><span class="line">                  </span><br><span class="line">                  color: yellow;</span><br><span class="line">              }</span><br><span class="line">              /*hover表示鼠标悬停时a标签的样式*/</span><br><span class="line">              .box ul li.item3 a:hover{</span><br><span class="line">                  </span><br><span class="line">                  color: green;</span><br><span class="line">              }</span><br><span class="line">              /*active表示鼠标摁住的时候a标签的样式*/</span><br><span class="line">              .box ul li.item4 a:active{</span><br><span class="line">                  </span><br><span class="line">                  color: yellowgreen;</span><br><span class="line">              }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>伪标签选择器(伪元素选择器)</p><ul><li>```html<br>/<em>设置第一个首字母的样式</em>/<pre><code> p:first-letter{        color: red;        font-size: 30px;    }    </code></pre>/* 在….之前 添加内容   这个属性使用不是很频繁 了解  使用此伪元素选择器一定要结合content属性*/<pre><code>    p:before{        content:'alex';    }        </code></pre>/<em>在….之后 添加内容，使用非常频繁 通常与咱们后面要讲到布局 有很大的关联（清除浮动）</em>/<pre><code>    p:after{        content:'&amp;';        color: red;        font-size: 40px;    }</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 属性选择器</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    /*根据for属性查找，找到所有又for属性的，设置字体颜色为红色*/</span><br><span class="line">               /*[for]{</span><br><span class="line">                   color: red;</span><br><span class="line">               }*/</span><br><span class="line">               </span><br><span class="line">               /*找到for属性的值等于username的元素 字体颜色设为黄色*/</span><br><span class="line">               /*[for='username']{</span><br><span class="line">                   color: yellow;</span><br><span class="line">               }*/</span><br><span class="line">               </span><br><span class="line">               /*以....开头  ^*/ </span><br><span class="line">               /*[for^='user']{</span><br><span class="line">                   color: #008000;</span><br><span class="line">               }*/</span><br><span class="line">               </span><br><span class="line">               /*以....结尾   $*/</span><br><span class="line">               /*[for$='vvip']{</span><br><span class="line">                   color: red;</span><br><span class="line">               }*/</span><br><span class="line">               </span><br><span class="line">               /*包含某元素的标签*/</span><br><span class="line">               /*[for*="vip"]{</span><br><span class="line">                   color: #00BFFF;</span><br><span class="line">               }*/</span><br><span class="line">               </span><br><span class="line">               /*指定标签的for属性</span><br><span class="line">               其中for属性的值是以空格隔开的值列表，</span><br><span class="line">               user1是值列表中的一个独立值*/</span><br><span class="line">               label[for~='user1']{</span><br><span class="line">                   color: red;</span><br><span class="line">               }</span><br><span class="line">               </span><br><span class="line">               input[type='text']{</span><br><span class="line">                   background: red;</span><br><span class="line">               }</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h3 id="4-选择器权重"><a href="#4-选择器权重" class="headerlink" title="4.选择器权重"></a>4.选择器权重</h3><ul><li><p>当同一个标签有多重样式,遇到重叠项的设置又该听谁的呢,这就涉及到权重的问题了,</p></li><li><p>行内样式 1000&gt;id选择器 100&gt;类选择器 10&gt;标签选择器 1&gt;继承样式</p></li><li><p>css的两大特性:继承性和层叠性</p><ul><li><p>继承性:给父级设置一些属性,子级继承父级的该属性,这就是css中的继承</p><ul><li><p>继承规则</p></li><li><p>```heml<br>面向对象语言都会存在继承的概念，在面向对象语言中，继承的特点：继承了父类的属性和方法。那么我们现在主要研究css，css就是在设置属性的。不会牵扯到方法的层面。</p><p>记住：有一些属性是可以继承下来 ： color 、 font-*、 text-<em>、line-</em> 。主要是文本级的标签元素。</p><p>但是像一些盒子元素属性，定位的元素（浮动，绝对定位，固定定位）不能继承</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 层叠性:权重大的标签覆盖掉权重小的标签,谁的权重大就显示谁的标签</span><br><span class="line"></span><br><span class="line">- 权重比较</span><br><span class="line"></span><br><span class="line">  - 权重一样的时候,是以后来设置的属性为准,</span><br><span class="line">  - 权重都是0,那么就遵循就近原则,谁描述的近,就使用谁的属性,谁描述的近,就是选中到最内层的距离越近</span><br><span class="line"></span><br><span class="line">- ! import:设置为权重无限大</span><br><span class="line"></span><br><span class="line">  - 它不影响继承来的权重,只影响选中的元素,不要随便使用,以为他会影响页面的布局</span><br><span class="line"></span><br><span class="line">- 使用什么选择器?</span><br><span class="line"></span><br><span class="line">  - 不要试图用一个类将页面写完,这个标签要携带多个类,共同设置样式</span><br><span class="line">  - 每个类尽可能的小,要有公共的概念,能让更多的标签使用.</span><br><span class="line">  - 在css中尽可能的使用classs,除非一些特殊的情况可以用id,id一般是用在js中的,也就是说js是通过id来获取到标签</span><br><span class="line"></span><br><span class="line">- 选择器的选择</span><br><span class="line"></span><br><span class="line">  - 先看标签元素有没有被选中,如果被选中了,就数数(id,class,标签的数量) 谁的权重大,就显示谁的属性,权重一样大,后来者居上</span><br><span class="line">  - 如果没有被选中标签,权重为0</span><br><span class="line">  - 如果属性都是被继承下来的,权重都是0,就近原则,谁描述的近就显示谁的属性</span><br><span class="line"></span><br><span class="line">### 5.盒模型</span><br><span class="line"></span><br><span class="line">- 在css中,box model这一术语是用来设计和布局时使用的,在网页中显示一些方方正正的盒子,这种盒子就叫盒模型</span><br><span class="line"></span><br><span class="line">- 盒模型有两种: 标准模型和IE模型(了解)</span><br><span class="line"></span><br><span class="line">- 盒模型属性</span><br><span class="line"></span><br><span class="line">  - width : 内容的宽度</span><br><span class="line"></span><br><span class="line">  - height : 内容的高度</span><br><span class="line"></span><br><span class="line">  - padding : 内边距,边框到内容的距离,padding区域是有背景颜色的,且背景颜色和内容的颜色一样,也就是说background-color这个属性将填充所有的border以内的区域</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      padding-top: 30px;</span><br><span class="line">      padding-right: 30px;</span><br><span class="line">      padding-bottom: 30px;</span><br><span class="line">      padding-left: 30px;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>border : 边框 ,盒子的宽度</p><ul><li><p>```html<br>/<em>上 右 下 左</em>/<br>padding: 20px 30px 40px 50px ;</p><p>/<em>上 左右  下</em>/<br>padding: 20px 30px 40px;</p><p>/* 上下 左右*/<br>padding: 20px 30px;</p><p>/<em>上下左右</em>/<br>padding: 20px;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 边框有三个要素,粗细,线性样式,颜色,(如不写粗细不显示边框,不写颜色默认黑色,只写线性样式,默认有上下左右 3px宽度的实体黑色边框</span><br><span class="line"></span><br><span class="line">- 按照三要素来写border</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    border-width: 3px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">    border-color: red;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    border-width: 5px 10px;</span><br><span class="line">    border-style: solid dotted double dashed;</span><br><span class="line">    border-color: red green yellow;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    /*设置顺序 ：上 右 左 下*/</span><br><span class="line">    /*border-style: 实线，点状，双线，虚线*/</span><br></pre></td></tr></tbody></table></figure></li><li><p>按照方向划分设置小属性</p><ul><li>```<br>border-top-width: 10px;<br>border-top-color: red;<br>border-top-style: solid;border-right-width: 10px;<br>border-right-color: red;<br>border-right-style: solid;border-bottom-width: 10px;<br>border-bottom-color: red;<br>border-bottom-style: solid;border-left-width: 10px;<br>border-left-color: red;<br>border-left-style:solid;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 按照方向设置</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    border-top: 10px solid red;</span><br><span class="line">    border-right: 10px solid red;</span><br><span class="line">    border-bottom: 10px solid red;</span><br><span class="line">    border-left: 10pxb solid red;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置border没有样式</p><ul><li><p>```<br>border:none；<br>border：0；<br>表示border没有设置样式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- border-radius属性</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html lang="en"&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset="UTF-8"&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            div.box1{</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                border-radius: 20px;</span><br><span class="line">                background-color: #f0809d;</span><br><span class="line">            }</span><br><span class="line">            div.box2{</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                border-radius: 100px;</span><br><span class="line">                background-color: #7ef0c2;</span><br><span class="line">            }</span><br><span class="line">            div.box3{</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                border-top-left-radius: 200px;</span><br><span class="line">                border-top-right-radius: 200px;</span><br><span class="line">                border-bottom-right-radius: 20px;</span><br><span class="line">                border-bottom-left-radius: 20px;</span><br><span class="line">                background-color: #b589f0;</span><br><span class="line">            }</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class="box1"&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class="box2"&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class="box3"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>利用border画三角形</p></li></ul></li></ul></li><li><p>margin : 外边框,盒子边框到附近盒子的距离</p><ul><li><p>在写网页的时候,一般要清除页面标签中的padding和margin,以便我们更好的去调整元素的位置</p><ul><li>```html<br>{<br>  padding:0;<br>  margin:0;<br>}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 效率不高,所以我们要是用并集选择器选中页面中应有的标签,搜索reset.css,可找到方法</span><br><span class="line"></span><br><span class="line">- 设置margin</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    /*表示四个方向的外边距离为20px*/</span><br><span class="line">    margin: 20px;</span><br><span class="line">    /*表示盒子向下移动了30px*/</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">    /*表示盒子向右移动了50px*/</span><br><span class="line">    margin-left: 50px;</span><br><span class="line">    /*表示盒子距离右面的盒子100px*/</span><br><span class="line">    margin-right: 100px;</span><br><span class="line">    /*表示盒子距离下面的盒子100px*/</span><br><span class="line">    margin-bottom: 100px;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>margin的塌陷</p><ul><li>```html<br>html:<div class="father">    <div class="box1"></div>            <div class="box2"></div></div>css:    *{            padding: 0;            margin: 0;        }        .father{            width: 400px;            border: 1px solid gray;            /*float: left;*/        }        .box1{            width: 300px;            height: 200px;            background-color: red;            margin-bottom: 20px;            /*float: left;*/        }        .box2{            width: 400px;            height: 300px;            background-color: green;            margin-top: 50px;            /*float: left;*/        }/*<br>当给两个标准流下兄弟盒子 设置垂直方向上的margin时，那么以较大的为准，那么我们称这种现象叫塌陷。没法解决，我们称为这种技巧叫“奇淫技巧”。记住这种现象，在布局垂直方向盒子的时候注意margin的用法。<br>当我们给两个标准流下的兄弟盒子设置浮动之后，就不会出现margin塌陷的问题。<br>*/<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- margin : 0 auto;</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    div{</span><br><span class="line">                width: 780px;</span><br><span class="line">                height: 50px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                /*水平居中盒子*/</span><br><span class="line">                margin: 0px auto;</span><br><span class="line">                            /*水平居中文字*/</span><br><span class="line">                text-align: center;</span><br><span class="line">    </span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">    /*当一个div元素设置margin：0 auto;时就会居中盒子，那我们知道margin:0 auto;表示上下外边距离为0，左右为auto的距离，那么auto是什么意思呢？</span><br><span class="line">    </span><br><span class="line">    设置margin-left:auto；我们发现盒子尽可能远离左侧，当设置margin-right:auto；我们发现盒子尽可能远离右侧。当两条语句并存的时候，我们发现盒子尽可能远离两侧，此时盒子就居中了。</span><br><span class="line">    </span><br><span class="line">    如果给盒子设置浮动，那么margin:0 auto失效。</span><br><span class="line">    </span><br><span class="line">    使用margin：0 auto;注意点：</span><br><span class="line">    </span><br><span class="line">    1.使用margin: 0 auto;水平居中盒子必须有width，要有明确width，文字水平居中使用text-align: center;</span><br><span class="line">    2.只有标准流下的盒子 才能使用margin:0 auto; </span><br><span class="line">    当一个盒子浮动了，固定定位，绝对定位(后面会讲)，margin:0 auto; 不能用了</span><br><span class="line">    3.margin：0 auto;居中盒子。而不是居中文本，文字水平居中使用text-align: center;</span><br><span class="line">    */</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>善于使用父亲的padding,而不是margin</p><ul><li>margin属性是描述兄弟盒子的关系,而padding描述的是父子盒子的关系</li><li>给父盒子设定border,或者padding,那么父盒子就不会因为子盒子的原因掉下来</li></ul></li></ul></li></ul><h3 id="6-标准文档流"><a href="#6-标准文档流" class="headerlink" title="6.标准文档流"></a>6.标准文档流</h3><ul><li>web网页的制作,从上往下设计,</li><li>空白折叠现象</li><li>高矮不齐,底边对齐<ul><li>图片文档的大小不一都会让页面出现高矮不齐的现象,但是遵循底边对齐</li></ul></li><li>自动换行,一行写不满,换行写</li></ul><h3 id="7-块级元素和行内元素的转换"><a href="#7-块级元素和行内元素的转换" class="headerlink" title="7.块级元素和行内元素的转换"></a>7.块级元素和行内元素的转换</h3><ul><li>行内元素<ul><li>与其他行内元素并排</li><li>不能设置宽高,默认的宽度就是文字的宽度</li></ul></li><li>块级元素<ul><li>霸占一行,不能与其他元素并列</li><li>能设置宽高,如果不设置宽高,那么宽度将默认变为父亲的100%</li></ul></li><li>相互转换<ul><li>可以通过display属性将会计元素和行内元素进行互相转换,display即”显示模式”</li><li>块级元素转换为行内元素<ul><li>display: inline;</li></ul></li><li>行内元素转换为块级元素<ul><li>display: block;</li></ul></li></ul></li></ul><h3 id="8-css脱离标准文档流的三种方式"><a href="#8-css脱离标准文档流的三种方式" class="headerlink" title="8.css脱离标准文档流的三种方式"></a>8.css脱离标准文档流的三种方式</h3><ul><li><p>浮动 ; float</p><ul><li><p>属性</p><ul><li>none:表示不浮动,默认</li><li>left,左浮动</li><li>right,右浮动</li></ul></li><li><p>四大特性</p><ul><li>浮动的元素会脱离标准文档流</li><li>浮动的元素互相贴靠</li><li>浮动的元素有”子围”效果<ul><li>当div浮动,p不浮动,div遮盖了p,div的层级提高,但是p中的文字不会被遮盖,此时就形成了子围效果</li></ul></li><li>收缩的效果<ul><li>一个浮动的元素,如果没有设置width,那么就自动收缩为文字的高度</li></ul></li></ul></li><li><p>清除浮动</p><ul><li><p>给父盒子设定高度,但是使用不灵活,常用于页面中固定高度,且子元素并排显示的布局,比如导航栏</p></li><li><p>clear:both</p><ul><li>left:当前元素的左边不许有浮动的元素</li><li>right: 当前元素的有边不许有浮动的元素</li><li>both:两边都不许有</li></ul></li><li><p>伪元素清除法(常用)</p><ul><li><p>给浮动子元素的父盒子,也就是不浮动元素,添加一个clearfix类,然后设置</p><ul><li>```html<br>.clearfix:after{<pre><code>/*必须要写这三句话*/content: '.';clear: both;display: block;</code></pre>}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - overflow:hidden</span><br><span class="line"></span><br><span class="line">    - overflow属性规定当内容溢出元素框时发生的事情。</span><br><span class="line"></span><br><span class="line">      说明：</span><br><span class="line"></span><br><span class="line">      这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。</span><br><span class="line"></span><br><span class="line">      有五个值：</span><br><span class="line"></span><br><span class="line">      | 值      | 描述                                                     |</span><br><span class="line">      | ------- | -------------------------------------------------------- |</span><br><span class="line">      | visible | 默认值。内容不会被修剪，会呈现在元素框之外。             |</span><br><span class="line">      | hidden  | 内容会被修剪，并且其余内容是不可见的。                   |</span><br><span class="line">      | scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 |</span><br><span class="line">      | auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 |</span><br><span class="line">      | inherit | 规定应该从父元素继承 overflow 属性的值。                 |</span><br><span class="line"></span><br><span class="line">- 定位</span><br><span class="line"></span><br><span class="line">  - 定位分为三种:决定定位,相对定位,固定定位</span><br><span class="line"></span><br><span class="line">  - 相对定位</span><br><span class="line"></span><br><span class="line">    - 现象和使用：</span><br><span class="line"></span><br><span class="line">      1.如果对当前元素仅仅设置了相对定位，那么与标准流的盒子什么区别。</span><br><span class="line"></span><br><span class="line">      2.设置相对定位之后，我们才可以使用四个方向的属性： top、bottom、left、right</span><br><span class="line"></span><br><span class="line">      特性：1.不脱标  2.形影分离  3.老家留坑（占着茅房不拉屎，恶心人）</span><br><span class="line"></span><br><span class="line">      所以说相对定位在页面中没有什么太大的作用。影响我们页面的布局。我们不要使用相对定位来做压盖效果</span><br><span class="line"></span><br><span class="line">      用途：</span><br><span class="line"></span><br><span class="line">      1.微调元素位置</span><br><span class="line"></span><br><span class="line">      2.做绝对定位的参考（父相子绝）绝对定位会说到此内容。</span><br><span class="line"></span><br><span class="line">  - 绝对定位</span><br><span class="line"></span><br><span class="line">    - 特性：1.脱标  2.做遮盖效果，提成了层级。设置绝对定位之后，不区分行内元素和块级元素，都能设置宽高。</span><br><span class="line"></span><br><span class="line">      参考点(重点)：</span><br><span class="line"></span><br><span class="line">      一、单独一个绝对定位的盒子</span><br><span class="line"></span><br><span class="line">      1.当我使用top属性描述的时候 是以页面的左上角（跟浏览器的左上角区分）为参考点来调整位置</span><br><span class="line">      2.当我使用bottom属性描述的时候。是以首屏页面左下角为参考点来调整位置。</span><br><span class="line"></span><br><span class="line">      二、以父辈盒子作为参考点</span><br><span class="line"></span><br><span class="line">      1.父辈元素设置相对定位，子元素设置绝对定位，那么会以父辈元素左上角为参考点，这个父辈元素不一定是爸爸，它也可以是爷爷，曾爷爷。</span><br><span class="line"></span><br><span class="line">      2.如果父亲设置了定位，那么以父亲为参考点。那么如果父亲没有设置定位，那么以父辈元素设置定位的为参考点</span><br><span class="line"></span><br><span class="line">      3.不仅仅是父相子绝，父绝子绝 ，父固子绝,都是以父辈元素为参考点</span><br><span class="line"></span><br><span class="line">      注意了：父绝子绝，没有实战意义，做站的时候不会出现父绝子绝。因为绝对定位脱离标准流，影响页面的布局。相反‘父相子绝’在我们页面布局中，是常用的布局方案。因为父亲设置相对定位，不脱离标准流，子元素设置绝对定位，仅仅的是在当前父辈元素内调整该元素的位置。</span><br><span class="line"></span><br><span class="line">      还要注意，绝对定位的盒子无视父辈的padding</span><br><span class="line"></span><br><span class="line">      **作用：页面布局常见的“父相子绝”，一定要会！！！！**</span><br><span class="line"></span><br><span class="line">  - 固定定位</span><br><span class="line"></span><br><span class="line">    - 固定当前的元素不会随着页面滚动而滚动</span><br><span class="line"></span><br><span class="line">      特性: 1.脱标 2.遮盖，提升层级 3.固定不变</span><br><span class="line"></span><br><span class="line">      参考点：</span><br><span class="line"></span><br><span class="line">      设置固定定位，用top描述。那么是以浏览器的左上角为参考点</span><br><span class="line">      如果用bottom描述，那么是以浏览器的左下角为参考点</span><br><span class="line"></span><br><span class="line">      作用： 1.返回顶部栏 2.固定导航栏 3.小广告</span><br><span class="line"></span><br><span class="line">  - z-index</span><br><span class="line"></span><br><span class="line">    - 指的就是各个盒子重叠在一起谁上谁下的问题。</span><br><span class="line"></span><br><span class="line">      四大特性，只要你记住了，页面布局就不会出现找不到盒子的情况。</span><br><span class="line"></span><br><span class="line">      - - - z-index 值表示谁压着谁，数值大的压盖住数值小的，</span><br><span class="line">          - 只有定位了的元素，才能有z-index,也就是说，不管相对定位，绝对定位，固定定位，都可以使用z-index，而浮动元素不能使用z-index</span><br><span class="line">          - z-index值没有单位，就是一个正整数，默认的z-index值为0如果大家都没有z-index值，或者z-index值一样，那么谁写在HTML后面，谁在上面压着别人，定位了元素，永远压住没有定位的元素。</span><br><span class="line">          - 从父现象：父亲怂了，儿子再牛逼也没用</span><br><span class="line"></span><br><span class="line">### 8.文本属性和字体属性</span><br><span class="line"></span><br><span class="line">- 文本属性</span><br><span class="line"></span><br><span class="line">  - | 属性            | 描述                 | 属性值                                          | 说明                                                         |</span><br><span class="line">    | --------------- | -------------------- | ----------------------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">    | text-align      | 文本对齐方式         | nonecenterleftrightjustify                      |                                                              |</span><br><span class="line">    | color           | 文本颜色             |                                                 |                                                              |</span><br><span class="line">    | text-indent     | 首行缩进，单位建议em |                                                 |                                                              |</span><br><span class="line">    | text-decoration | 规定文本修饰的样式   | none   underline  overline  line-throughinherit | 默认下划线定义文本上的一条线定义穿过文本下的一条线继承父元素text-decoration属性的值 |</span><br><span class="line">    | line-height     | 行高                 |                                                 | 针对单行文本垂直居中公式：行高=盒子高度，使文本垂直居中，只适用单行文本。针对多行文本垂直居中行高不能小于字体，不然字会紧挨一起。 |</span><br><span class="line">    | text-shadow     | 阴影                 | 5px 5px 5px #FF0000                             | 水平方向偏移量垂直方向偏移量模糊度阴影颜色                   |</span><br><span class="line">    | text-overflow   | 文字溢出             | clipellipsis                                    | 修剪文本显示省略号代表被修剪文本                             |</span><br><span class="line">    | white-space     | 处理元素内的空白     | normalprenowrappre-wrappre-lineinherit          | 默认。空白被浏览器忽略。空白会被浏览器保留文本不换行，直到遇到 &lt;br&gt;保留空白符序列，但正常地进行换行合并空白符序列，但是保留换行符继承父元素 white-space 属性的值 |</span><br><span class="line"></span><br><span class="line">- 字体属性</span><br><span class="line"></span><br><span class="line">  - | 属性            | 描述                 | 属性值                                          | 说明                                                         |</span><br><span class="line">    | --------------- | -------------------- | ----------------------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">    | text-align      | 文本对齐方式         | nonecenterleftrightjustify                      |                                                              |</span><br><span class="line">    | color           | 文本颜色             |                                                 |                                                              |</span><br><span class="line">    | text-indent     | 首行缩进，单位建议em |                                                 |                                                              |</span><br><span class="line">    | text-decoration | 规定文本修饰的样式   | none   underline  overline  line-throughinherit | 默认下划线定义文本上的一条线定义穿过文本下的一条线继承父元素text-decoration属性的值 |</span><br><span class="line">    | line-height     | 行高                 |                                                 | 针对单行文本垂直居中公式：行高=盒子高度，使文本垂直居中，只适用单行文本。针对多行文本垂直居中行高不能小于字体，不然字会紧挨一起。 |</span><br><span class="line">    | text-shadow     | 阴影                 | 5px 5px 5px #FF0000                             | 水平方向偏移量垂直方向偏移量模糊度阴影颜色                   |</span><br><span class="line">    | text-overflow   | 文字溢出             | clipellipsis                                    | 修剪文本显示省略号代表被修剪文本                             |</span><br><span class="line">    | white-space     | 处理元素内的空白     | normalprenowrappre-wrappre-lineinherit          | 默认。空白被浏览器忽略。空白会被浏览器保留文本不换行，直到遇到 &lt;br&gt;保留空白符序列，但正常地进行换行合并空白符序列，但是保留换行符继承父元素 white-space 属性的值 |</span><br><span class="line"></span><br><span class="line">### 9.background</span><br><span class="line"></span><br><span class="line">- background-color : 背景颜色</span><br><span class="line"></span><br><span class="line">- background-image : 背景图片</span><br><span class="line"></span><br><span class="line">  - | background-repeat：设置背景图像的平铺方式   |                                                              |</span><br><span class="line">    | ------------------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">    | repeatrepeat-xrepeat-yno-repeateinherit     | 默认。背景图像将在垂直方向和水平方向重复背景图像将在水平方向重复背景图像将在垂直方向重复背景图像将仅显示一次规定应该从父元素继承 background-repeat 属性的设置 |</span><br><span class="line">    | background-position：设置背景图像的起始位置 |                                                              |</span><br><span class="line">    | 垂直位置 水平位置                           | 可以从两个纬度上设定关键词：上中下 左中右垂直位置：top center bottom水平位置：left center right如仅规定了一个关键词，那么第二个值将是"center"。默认值：0 0；这两个值必须挨在一起。 |</span><br><span class="line">    | background-attachment：设置固定的背景图像   |                                                              |</span><br><span class="line">    | scrollfixedinherit                          | 默认值。背景图像会随着页面其余部分的滚动而移动。当页面的其余部分滚动时，背景图像不会移动。规定应该从父元素继承 background-attachment 属性的设置。 |</span><br><span class="line"></span><br><span class="line"># JavaScript篇</span><br><span class="line"></span><br><span class="line">## ECMAScript:语法标准</span><br><span class="line"></span><br><span class="line">### 1.js介绍</span><br><span class="line"></span><br><span class="line">- JavaScript分为三层</span><br><span class="line">  - ECMAScript : JavaScript的语法标准,包括变量,表达式,运算符,函数,if语句,for语句等</span><br><span class="line">  - DOM : 文档对象模型,操作网页上的元素的API,比如让盒子移动变色轮播图等</span><br><span class="line">  - BOM : 浏览器对象模型,操作浏览器功能的部分API,比如让浏览器自动滚动</span><br><span class="line">- 优点</span><br><span class="line">  - JavaScript对初学者比较友好</span><br><span class="line">  - JavaScript是有界面效果的(比如C语言就只有白底黑字)</span><br><span class="line">  - JavaScript是弱变量型的语言,变量只需要用var来声明,而java中的变量的声明,要根据变量的类型来定义</span><br><span class="line">- 特点</span><br><span class="line">  - 简单易用:可以使用任何的文本编辑器编写,只需要浏览器就能执行程序</span><br><span class="line">  - 解释执行(解释语言) ; 事先不编译,逐行执行,无需进行严格的变量声明</span><br><span class="line">- 语法要求</span><br><span class="line">  - JavaScript对换行缩进空格不敏感</span><br><span class="line">  - 所有的符号都是英文的</span><br><span class="line">- js代码的引入</span><br><span class="line">  - 在页面中，我们可以在body标签中放入`&lt;script type=”text/javascript”&gt;&lt;/script&gt;`标签对儿，`&lt;script type=”text/javascript”&gt;&lt;/script&gt;`标签对儿</span><br><span class="line"></span><br><span class="line">### 2.js变量和复制</span><br><span class="line"></span><br><span class="line">- 变量</span><br><span class="line">  - 变量有命名规范: 只能有字母数字下划线,美元符号$构成,且不能以数字开头,并且不能是JavaScript中的保留字,变量区分大小写</span><br><span class="line">- 赋值</span><br><span class="line">  - 将等号右边的值,赋值给左边的变量,等号右边的变量的值不变</span><br><span class="line">- 注释</span><br><span class="line">  - 单行注释(//)是ctrl + /,多汗注释(/*   */)是ctrl + shift +/</span><br><span class="line"></span><br><span class="line">### 3.输入输出信息</span><br><span class="line"></span><br><span class="line">- 弹出警告框 : alert语句</span><br><span class="line">- 控制台输出console.log("")和输入框prompt()</span><br><span class="line"></span><br><span class="line">### 4.基础数据类型</span><br><span class="line"></span><br><span class="line">- number</span><br><span class="line"></span><br><span class="line">  - JavaScript中只要是数就是数值型的(number),无论整数,浮点数,无论大小,无论正负,都是number类型的</span><br><span class="line"></span><br><span class="line">- string ; 字符串类型</span><br><span class="line"></span><br><span class="line">  - 常用方法</span><br><span class="line"></span><br><span class="line">    - | 方法                                                         | 说明               |</span><br><span class="line">      | ------------------------------------------------------------ | ------------------ |</span><br><span class="line">      | .length   #不加括号的是属性                                  | 返回长度           |</span><br><span class="line">      | .trim()    #得到一个新值                                     | 移除空白           |</span><br><span class="line">      | .trimLeft()                                                  | 移除左边的空白     |</span><br><span class="line">      | .trimRight()                                                 | 移除右边的空白     |</span><br><span class="line">      | .concat(value, ...) #s1='hello';s.concat('xx');得到helloxx   | 拼接               |</span><br><span class="line">      | .charAt(n) #n类似索引，从0开始，超过最大值返回''空字符串     | 返回第n个字符      |</span><br><span class="line">      | .indexOf(substring, start) #这个start是从索引几开始找，没有返回-1 | 子序列位置         |</span><br><span class="line">      | .substring(from, to) #不支持负数，所以一般都不用它，了解一下就行了 | 根据索引获取子序列 |</span><br><span class="line">      | .slice(start, end) #var s1='helloworld';s1.slice(0,-5)看结果，就用它 | 切片               |</span><br><span class="line">      | .toLowerCase() #全部变小写                                   | 小写               |</span><br><span class="line">      | .toUpperCase()  #全部变大写                                  | 大写               |</span><br><span class="line">      | .split(delimiter, limit)#分隔,s1.splite(' '),后面还可以加参数s1.split(' '，2),返回切割后的元素个数 | 分割               |</span><br><span class="line"></span><br><span class="line">- 布尔值 : boolean</span><br><span class="line"></span><br><span class="line">- 空元素 : null</span><br><span class="line"></span><br><span class="line">- 未定义 : undefined</span><br><span class="line"></span><br><span class="line">### 5.内置数据类型</span><br><span class="line"></span><br><span class="line">- 数组.Array</span><br><span class="line"></span><br><span class="line">  - 数组的创建</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      var colors = ['red','color','yellow']; //字面量方式创建（推荐）</span><br><span class="line">      var colors2 = new Array();//使用构造函数（后面会讲）的方式创建 使用new关键词对构造函数进行创建对象</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li><li><p>数组的赋值</p><ul><li>```html<br>var arr = [];<br>//通过下标进行一一赋值<br>arr[0] = 123;<br>arr[1] = ‘哈哈哈’;<br>arr[2] = ‘嘿嘿嘿’<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 数组的常用方法</span><br><span class="line"></span><br><span class="line">  - | 方法                                                         | 说明                                       |</span><br><span class="line">    | ------------------------------------------------------------ | ------------------------------------------ |</span><br><span class="line">    | .length                                                      | 数组的大小                                 |</span><br><span class="line">    | .push(ele)                                                   | 尾部追加元素                               |</span><br><span class="line">    | .pop()                                                       | 获取尾部的元素                             |</span><br><span class="line">    | .unshift(ele)                                                | 头部插入元素                               |</span><br><span class="line">    | .shift()                                                     | 头部移除元素                               |</span><br><span class="line">    | .slice(start, end)                                           | 切片                                       |</span><br><span class="line">    | .reverse() #在原数组上改的                                   | 反转                                       |</span><br><span class="line">    | .join(seq)#a1.join('+')，seq是连接符                         | 将数组元素连接成字符串                     |</span><br><span class="line">    | .concat(val, ...) #连个数组合并,得到一个新数组，原数组不变   | 连接数组                                   |</span><br><span class="line">    | .sort()                                                      | 排序                                       |</span><br><span class="line">    | .forEach() #讲了函数再说                                     | 将数组的每个元素传递给回调函数             |</span><br><span class="line">    | .splice() #参数：1.从哪删(索引), 2.删几个  3.删除位置替换的新元素(可多个元素) | 删除元素，并向数组添加新元素。             |</span><br><span class="line">    | .map()  #讲了函数再说                                        | 返回一个数组元素调用函数处理后的值的新数组 |</span><br><span class="line"></span><br><span class="line">- json对象</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    var str1 = '{"name": "chao", "age": 18}';</span><br><span class="line">    var obj1 = {"name": "chao", "age": 18};</span><br><span class="line">    // JSON字符串转换成对象</span><br><span class="line">    var obj = JSON.parse(str1); </span><br><span class="line">    // 对象转换成JSON字符串</span><br><span class="line">    var str = JSON.stringify(obj1);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>日期: Date</p><ul><li><p>定义</p><ul><li><p>创建日期对象只有构造函数一种方式,使用关键字new</p></li><li><p>```html<br>var myDate = new Date();  //创建了一个date对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 常用方法</span><br><span class="line"></span><br><span class="line">    - ![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180527115655555-1984356276.png)</span><br><span class="line"></span><br><span class="line">- RegExp对象</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    //RegExp对象</span><br><span class="line">    </span><br><span class="line">    //创建正则对象方式1</span><br><span class="line">    // 参数1 正则表达式(不能有空格)</span><br><span class="line">    // 参数2 匹配模式：常用g(全局匹配;找到所有匹配，而不是在第一个匹配后停止)和i(忽略大小写)</span><br><span class="line">    </span><br><span class="line">    // 用户名只能是英文字母、数字和_，并且首字母必须是英文字母。长度最短不能少于6位 最长不能超过12位。</span><br><span class="line">    </span><br><span class="line">    // 创建RegExp对象方式（逗号后面不要加空格），假如匹配用户名是只能字母开头后面是字母加数字加下划线的5到11位的</span><br><span class="line">    var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]{5,11}$"); //注意，写规则的时候，里面千万不能有空格，不然匹配不出来你想要的内容，除非你想要的内容本身就想要空格，比如最后这个{5,11},里面不能有空格</span><br><span class="line">    </span><br><span class="line">    // 匹配响应的字符串</span><br><span class="line">    var s1 = "bc123";</span><br><span class="line">    </span><br><span class="line">    //RegExp对象的test方法，测试一个字符串是否符合对应的正则规则，返回值是true或false。</span><br><span class="line">    reg1.test(s1);  // true</span><br><span class="line">    </span><br><span class="line">    // 创建方式2，简写的方式</span><br><span class="line">    // /填写正则表达式/匹配模式（逗号后面不要加空格）</span><br><span class="line">    var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/; </span><br><span class="line">    </span><br><span class="line">    reg2.test(s1);  // true</span><br><span class="line">    </span><br><span class="line">    注意，此处有坑：如果你直接写一个reg2.test()，test里面啥也不传，直接执行，会返回一个true，用其他的正则规则，可能会返回false，是因为，test里面什么也不传，默认传的是一个undefined，并且给你变成字符串undefined，所以能够匹配undefined的规则，就能返回true，不然返回false</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // String对象与正则结合的4个方法</span><br><span class="line">    var s2 = "hello world";</span><br><span class="line">    </span><br><span class="line">    s2.match(/o/g);         // ["o", "o"]             查找字符串中 符合正则 的内容 ，/o/g后面这个g的意思是匹配所有的o,</span><br><span class="line">    s2.search(/h/g);        // 0                      查找字符串中符合正则表达式的内容位置，返回第一个配到的元素的索引位置，加不加g效果相同</span><br><span class="line">    s2.split(/o/g);         // ["hell", " w", "rld"]  按照正则表达式对字符串进行切割，得到一个新值，原数据不变</span><br><span class="line">    s2.replace(/o/g, "s");  // "hells wsrld"          对字符串按照正则进行替换</span><br><span class="line">    </span><br><span class="line">    // 关于匹配模式：g和i的简单示例</span><br><span class="line">    var s1 = "name:Alex age:18";</span><br><span class="line">    </span><br><span class="line">    s1.replace(/a/, "哈哈哈");      // "n哈哈哈me:Alex age:18"</span><br><span class="line">    s1.replace(/a/g, "哈哈哈");     // "n哈哈哈me:Alex 哈哈哈ge:18"      全局匹配</span><br><span class="line">    s1.replace(/a/gi, "哈哈哈");    // "n哈哈哈me:哈哈哈lex 哈哈哈ge:18"  不区分大小写</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 注意事项1：</span><br><span class="line">    // 如果regExpObject带有全局标志g，test()函数不是从字符串的开头开始查找，而是从属性regExpObject.lastIndex所指定的索引处开始查找。</span><br><span class="line">    // 该属性值默认为0，所以第一次仍然是从字符串的开头查找。</span><br><span class="line">    // 当找到一个匹配时，test()函数会将regExpObject.lastIndex的值改为字符串中本次匹配内容的最后一个字符的下一个索引位置。</span><br><span class="line">    // 当再次执行test()函数时，将会从该索引位置处开始查找，从而找到下一个匹配。</span><br><span class="line">    // 因此，当我们使用test()函数执行了一次匹配之后，如果想要重新使用test()函数从头开始查找，则需要手动将regExpObject.lastIndex的值重置为 0。</span><br><span class="line">    // 如果test()函数再也找不到可以匹配的文本时，该函数会自动把regExpObject.lastIndex属性重置为 0。</span><br><span class="line">    </span><br><span class="line">    var reg3 = /foo/g;</span><br><span class="line">    // 此时 regex.lastIndex=0</span><br><span class="line">    reg3.test('foo'); // 返回true</span><br><span class="line">    // 此时 regex.lastIndex=3</span><br><span class="line">    reg3.test('xxxfoo'); // 还是返回true</span><br><span class="line">    // 所以我们在使用test()方法校验一个字符串是否完全匹配时，一定要加上^和$符号，把匹配规则写的确定一些，尽量不用上面这种的写法/xxx/。</span><br><span class="line">    </span><br><span class="line">    // 注意事项2(说出来你可能不信系列)：</span><br><span class="line">    // 当我们不加参数调用RegExpObj.test()方法时, 相当于执行RegExpObj.test(undefined)，然后将这个undefined又转为字符串"undefined",去进行匹配了, 并且/undefined/.test()默认返回true。</span><br><span class="line">    var reg4 = /^undefined$/;</span><br><span class="line">    reg4.test(); // 返回true</span><br><span class="line">    reg4.test(undefined); // 返回true</span><br><span class="line">    reg4.test("undefined"); // 返回true</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>数学相关 Math</p><ul><li>常用方法</li><li><img src="https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180527115730266-1931075271.png" alt="img"></li></ul></li></ul></li></ul><h3 id="6-数据类型之间的转换"><a href="#6-数据类型之间的转换" class="headerlink" title="6.数据类型之间的转换"></a>6.数据类型之间的转换</h3><ul><li><p>parseint() : 字符串转数字</p></li><li><p>parseFloat() : 字符串转小数</p></li><li><p>String() 和.toString() : 转字符串</p><ul><li>```html<br>var n1 = 123;<br>var str1 = String(n1);<br>console.log(typeof str1);var num = 234;<br>console.log(num.toString())<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Boolean() : 任何数据类型都可以转成布尔值</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    var b1 = '123';  // true</span><br><span class="line">    var b3 = -123;  // true</span><br><span class="line">    var b4 = Infinity; //表示正无穷大 true</span><br><span class="line">    </span><br><span class="line">    var b2 = 0;       // false</span><br><span class="line">    var b5 = NaN;     //false</span><br><span class="line">    var b6;              //表示undefined //false</span><br><span class="line">    var b7 = null;    //false</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h3><ul><li>字符串可以相加,数字也可以相加,字符串和数字也可以相加,但是会自动把结果转换成字符串</li><li>字符串 - 数值 = 数值</li></ul><h3 id="8-流程控制"><a href="#8-流程控制" class="headerlink" title="8.流程控制"></a>8.流程控制</h3><ul><li><p>if单分支</p></li><li><p>if…else…</p></li><li><p>if…else if…else</p></li><li><p>case语句</p><ul><li>```html<br>var gameScore = ‘better’;<br>switch(gameScore){<br>//case表示一个条件 满足这个条件就会走进来 遇到break跳出。如果某个条件中不写 break，那么直到该程序遇到下一个break停止<pre><code>case 'good':console.log('玩的很好')//break表示退出break;case  'better':console.log('玩的老牛逼了')break;case 'best':console.log('恭喜你 吃鸡成功')break;default:console.log('很遗憾')</code></pre>}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- while循环</span><br><span class="line"></span><br><span class="line">- do-while循环</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    //不管有没有满足while中的条件do里面的代码都会走一次</span><br><span class="line">    var i = 3;//初始化循环变量</span><br><span class="line">    do{</span><br><span class="line">    </span><br><span class="line">        console.log(i)</span><br><span class="line">        i++;//更新循环条件</span><br><span class="line">    </span><br><span class="line">    }while (i&lt;10) //判断循环条件</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>for循环</p></li><li><p>三元运算符</p><ul><li>```html<br>var a = 1<br>var b =2<br>var c = a&gt;b ? a:b  //如果a&gt;b成立返回a，否则返回b<br>console.log(c)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 9.函数</span><br><span class="line"></span><br><span class="line">- 函数的定义</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    function 函数名字(){</span><br><span class="line">    </span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>函数的调用</p><ul><li>函数名();</li></ul></li><li><p>函数的参数和返回值:形参和实参</p><ul><li>注意: 实际参数和形式参数的个数,要相同</li><li>注意: 函数只能返回一个值,如果要返回多个值,只能将其放在数组或者对象中返回</li></ul></li><li><p>伪数组 : arguments</p><ul><li>arguments代表的是实参,arguments只在函数中使用</li><li>返回函数实参的个数 : arguments.length</li><li>获取形参的个数 : 函数名.length</li><li>之所以说arguments是伪数组,是因为; arguments可以修改元素,但是不能改变数组的长短</li></ul></li><li><p>匿名函数</p><ul><li>```html<br>// 匿名函数方式，多和其他函数配合使用，后面我们就会用到了<br>var sum = function(a, b){  //在es6中，使用var，可能会飘黄，是因为在es6中，建议你使用let来定义变量，不过不影响你使用<br>  return a + b;<br>}<br>sum(1, 2);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自执行函数</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    // 立即执行函数，页面加载到这里，这个函数就直接执行了，不需要被调用执行</span><br><span class="line">    (function(a, b){</span><br><span class="line">      return a + b;</span><br><span class="line">    })(1, 2);  //python中写可以这么写：ret=(lambda x,y:x+y)(10,20) 然后print(ret)</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>函数的全局变量和局部变量</p><ul><li>局部变量: 在函数内部使用var声明的是局部变量,只有函数内部能访问它,函数运行完毕就会消失</li><li>全局变量: 在函数外部声明的变量是全局变量,网页上的所有脚本和函数都鞥呢访问它,全局变量会在页面关闭后删除</li></ul></li><li><p>作用域</p><ul><li>函数内部查找变量,如果找不到会再到外部查找,逐步找到最外层</li></ul></li></ul><h3 id="10-面向对象-了解"><a href="#10-面向对象-了解" class="headerlink" title="10.面向对象(了解)"></a>10.面向对象(了解)</h3><ul><li>创建对象的几种常用方式<ul><li>使用object或对象字面量创建对象</li><li>工厂模式创建对象</li><li>构造函数模式创建对象</li><li>原型模式创建对象</li></ul></li></ul><h3 id="11正则的用法"><a href="#11正则的用法" class="headerlink" title="11正则的用法"></a>11正则的用法</h3><ul><li><p>```html<br>创建一个正则:<br>var reg = RegExp(‘正则表达式’)  //注意,写在字符串中所有带\的元字符都会被转义,应该写作\<br>var reg2 = /正则表达式/  //内部的元字符就不会转义了<br>reg.test(‘待检测的字符串’) //如果字符串中含有符合表达式规则的内容就返回true,否则返回false</p><p>在字符串中应用正则<br>var exp = ‘alex3714’<br>exp.match(/\d/)    //只匹配从左到右的第一个<br>exp.match(/\d/g)   //匹配所有符合规则的 返回一个数组<br>var exp2 = ‘Alex is a big sb’<br>exp2.match(/a/) //只匹配小写a<br>exp2.match(/a/i) //i表示不区分大小写 A也会被匹配出来<br>exp2.match(/a/ig) //不区分大小写并匹配所有</p><p>exp.search(/正则表达式/i) //不区分大小写,从exp字符串中找出符合条件的子串的第一个索引位置<br>exp.split(/正则表达式/i,n) //不区分大小写,根据正则切割,返回前n个结果<br>exp.replace(/正则/gi,’新的值’) //i表示不区分大小写,g表示替换所有,将符合正则条件的内容替换成新的值</p><p>小问题1<br>var reg2 = /\d/g     //正则表示要匹配多个值<br>reg2.test(‘a1b2c3’)  //多次test会的到true true true false 继续test会循环之前的结果</p><p>小问题2<br>var reg3 = /\w{5,10}/<br>reg3.test() //如果什么都不写,那么默认test中传递undefined参数,刚好可以符合9位字符串的规则</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## DOM:文档对象模型</span><br><span class="line"></span><br><span class="line">### 1.DOM</span><br><span class="line"></span><br><span class="line">- DOM:文档对象模型,DOM为文档提供了结构化表示,并定义了如何通过脚本来访问文档结构,目的其实是为了能让js操作heml元素而制定的一个规范</span><br><span class="line">- DOM就是由节点组成: heml加载完毕,渲染引擎会在内存中把HTML文档生成一个DOM树![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180528220440235-730879308.png)</span><br><span class="line"></span><br><span class="line">- 由上图可知,在HTML中一切都是节点&lt;font color=red&gt;非常重要&lt;/font&gt;</span><br><span class="line">  - 元素节点: HTML标签</span><br><span class="line">  - 文本节点: 标签中的文字(比如标签之间的空格,换行)</span><br><span class="line">  - 属性节点: 标签的属性</span><br><span class="line">  - 整个html文档就是一个文档节点所有节点都是Object</span><br><span class="line">- 利用DOM可以完成</span><br><span class="line">  - 找对象(元素节点)</span><br><span class="line">  - 设置元素的属性值</span><br><span class="line">  - 设置元素的样式</span><br><span class="line">  - 动态创建和删除元素</span><br><span class="line">  - 事件的触发响应: 事件源,事件,事件的驱动程序</span><br><span class="line"></span><br><span class="line">### 2.节点查找</span><br><span class="line"></span><br><span class="line">- DOM节点的获取方式其实就是获取事件源的方式</span><br><span class="line"></span><br><span class="line">- 直接查找:</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    var div1 = document.getElementById("box1");      //方式一：通过id获取单个标签</span><br><span class="line">    var arr1 = document.getElementsByTagName("div1");     //方式二：通过 标签名 获得 标签数组，所以有s</span><br><span class="line">    var arr2 = document.getElementsByClassName("hehe");  //方式三：通过 类名 获得 标签数组，所以有s</span><br><span class="line">    //其中方式二、方式三获取的是标签数组，那么习惯性是先遍历之后再使用。</span><br></pre></td></tr></tbody></table></figure><ul><li><p>特殊情况,只有一个元素</p></li><li><p>```html<br>即便如此，这一个值也是包在数组里的。这个值的获取方式如下：<br>document.getElementsByTagName(“div1”)[0];    //取数组中的第一个元素<br>document.getElementsByClassName(“hehe”)[0];  //取数组中的第一个元素</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 间接查找</span><br><span class="line"></span><br><span class="line">  - DOM的节点并不是孤立的,因此可以通过DOM节点之间的相对关系对他们进行访问,节点的访问呢关系是以属性的方式存在的![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180528220938094-853745001.png)</span><br><span class="line"></span><br><span class="line">  - 获取父节点</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      节点.parentNode</span><br></pre></td></tr></tbody></table></figure></li><li><p>获取兄弟节点</p><ul><li><p><strong>总结</strong>：为了获取下一个<strong>元素节点</strong>，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling</p></li><li><p>为了获取前一个<strong>元素节点</strong>，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling</p></li><li><p>随意兄弟节点</p><ul><li><p>```html<br>节点自己.parentNode.children[index];  //随意得到兄弟节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取子节点</span><br><span class="line"></span><br><span class="line">  - 单个子节点</span><br><span class="line"></span><br><span class="line">    - **总结**：为了获取第一个**子元素节点**，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild</span><br><span class="line">    - **总结**：为了获取最后一个**子元素节点**，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild</span><br><span class="line"></span><br><span class="line">  - 所有子节点</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      子节点数组 = 父节点.childNodes;   //获取所有节点。</span><br></pre></td></tr></tbody></table></figure></li><li><p>```html<br>子节点数组 = 父节点.children;   //获取所有节点。用的最多。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  nodeType == 1 表示的是元素节点（标签） 。记住：元素就是标签。</span><br><span class="line">  </span><br><span class="line">  nodeType == 2 表示是属性节点 了解</span><br><span class="line">  </span><br><span class="line">  nodeType == 3 是文本节点 了解</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="3-节点操作"><a href="#3-节点操作" class="headerlink" title="3.节点操作"></a>3.节点操作</h3><ul><li><p>节点本身操作</p><ul><li><p>创建节点</p><ul><li>```html<br>新的标签(元素节点) = document.createElement(“标签名”);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 比如,创建一个li标签,或者创建一个不存在的adg标签,可以这样做</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;script type="text/javascript"&gt;</span><br><span class="line">        var a1 = document.createElement("li");   //创建一个li标签</span><br><span class="line">        var a2 = document.createElement("adbc");   //创建一个不存在的标签</span><br><span class="line">    </span><br><span class="line">        console.log(a1);</span><br><span class="line">        console.log(a2);</span><br><span class="line">    </span><br><span class="line">        console.log(typeof a1);</span><br><span class="line">        console.log(typeof a2);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>插入节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父节点.appendChild(新的子节点);//方式1：父节点的最后插入一个新的子节点。 </span><br><span class="line">父节点.insertBefore(新的子节点,作为参考的子节点);//方式2：在参考节点前插入一个新的节点。如果参考节点为null，那么他将在父节点最后插入一个子节点。</span><br></pre></td></tr></tbody></table></figure></li><li><p>删除节点</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父节点.removeChild(子节点);//用父节点删除子节点。必须要指定是删除哪个子节点。</span><br><span class="line">node1.parentNode.removeChild(node1);//删除自己这个节点</span><br></pre></td></tr></tbody></table></figure></li><li><p>复制节点（克隆节点）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要复制的节点.cloneNode();       //括号里不带参数和带参数false，效果是一样的。不带参数/带参数false：只复制节点本身，不复制子节点。</span><br><span class="line">要复制的节点.cloneNode(true);   //带参数true：既复制节点本身，也复制其所有的子节点。</span><br></pre></td></tr></tbody></table></figure></li><li><p>替换节点</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父节点.replaceChild(newnode, 某个节点);   //找到这个父标签里面的要被替换的子标签，然后用新的标签将该子标签替换掉</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>节点的属性操作</p><ul><li><p>获取节点属性值</p><ul><li>```html<br>元素节点.属性;<br>元素节点[属性];<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  元素节点.getAttribute("属性名称");</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置节点属性值</p><ul><li>```html<pre><code>myNode.src = "images/2.jpg"   //修改src的属性值myNode.className = "image2-box";  //修改class的name</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  元素节点.setAttribute(属性名, 新的属性值);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>删除节点的属性</p><ul><li>```html<br>元素节点.removeAttribute(属性名);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 节点文本操作</span><br><span class="line"></span><br><span class="line">  - 获取文本节点的值</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      var divEle = document.getElementById("d1")</span><br><span class="line">      divEle.innerText  #输入这个指令，一执行就能获取该标签和内部所有标签的文本内容</span><br><span class="line">      divEle.innerHTML  #获取的是该标签内的所有内容，包括文本和标签</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置文本节点的值</p><ul><li>```html<br>var divEle = document.getElementById(“d1”)<br>divEle.innerText=”1”<br>divEle.innerHTML=”<p>2</p>“ #能识别成一个p标签<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取值的操作</span><br><span class="line"></span><br><span class="line">  - elemenNode.value  ; 适用于以下标签 ,用户输入或者选择类型的标签: input,select,textarea</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      var iEle = document.getElementById("i1");</span><br><span class="line">      console.log(iEle.value);</span><br><span class="line">      var sEle = document.getElementById("s1");</span><br><span class="line">      console.log(sEle.value);</span><br><span class="line">      var tEle = document.getElementById("t1");</span><br><span class="line">      console.log(tEle.value);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>class的操作</p><ul><li><p>```html<br>className  获取所有样式类名(字符串)<br>首先获取标签对象<br>标签对象.classList.remove(cls)  删除指定类<br>classList.add(cls)  添加类<br>classList.contains(cls)  存在返回true，否则返回false<br>classList.toggle(cls)  存在就删除，否则添加，toggle的意思是切换，有了就给你删除，如果没有就给你加一个</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 指定css的操作</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    obj.style.backgroundColor="red"</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于没有中横线的css属性直接用style.属性名即可,如:</p><ul><li>```html<br>obj.style.margin<br>obj.style.width<br>obj.style.left<br>obj.style.position<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对于含有中横线的css属性,将中横线后面的第一个字母换成大写即可,如</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    obj.style.marginTop</span><br><span class="line">    obj.style.borderLeftWidth</span><br><span class="line">    obj.style.zIndex</span><br><span class="line">    obj.style.fontFamily</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h3 id="4-事件"><a href="#4-事件" class="headerlink" title="4.事件"></a>4.事件</h3><ul><li><p>JS是以事件驱动为核心的一门语言</p></li><li><p>事件三要素</p><ul><li>事件源,事件,事件驱动程序</li></ul></li><li><p>代码书写步骤</p><ul><li>```html<br>（1）获取事件源：document.getElementById(“box”); //类似与ios语言的 UIButton *adBtn = [UIButton buttonWithType:UIButtonTypeCustom];<br>（2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };<br>（3）书写事件驱动程序：关于DOM的操作<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 常见事件如下![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180528212850888-1985583768.png)</span><br><span class="line"></span><br><span class="line">- 获取事件源</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    var div1 = document.getElementById("box1");      //方式一：通过id获取单个标签</span><br><span class="line">    var arr1 = document.getElementsByTagName("div1");     //方式二：通过 标签名 获得 标签数组，所以有s</span><br><span class="line">    var arr2 = document.getElementsByClassName("hehe");  //方式三：通过 类名 获得 标签数组，所以有s　</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>绑定事件的方式</p><ul><li><p>直接绑定匿名函数</p></li><li><p>```html</p><div id="box1"></div><script type="text/javascript">    var div1 = document.getElementById("box1");    //绑定事件的第一种方式    div1.onclick = function () {        alert("我是弹出的内容");    }</script><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 先单独定义函数,再绑定</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;div id="box1" &gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script type="text/javascript"&gt;</span><br><span class="line">      var div1 = document.getElementById("box1");</span><br><span class="line">      //绑定事件的第二种方式</span><br><span class="line">      div1.onclick = fn;   //注意，这里是fn，不是fn()。fn()指的是返回值。</span><br><span class="line">      //单独定义函数</span><br><span class="line">      function fn() {</span><br><span class="line">          alert("我是弹出的内容");</span><br><span class="line">      }</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="yellow">注意上方代码的注释,绑定的时候,是fn,不是写fn(),fn代表的是整个函数,fn()代表的是返回值</font></li></ul></li><li><p>行内绑定</p></li><li><p>```html</p><!--行内绑定--><div id="box1" onclick="fn()"></div><script type="text/javascript">    function fn() {        alert("我是弹出的内容");    }</script><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 事件驱动程序</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">            #box {</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: pink;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">            }</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div id="box" &gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type="text/javascript"&gt;</span><br><span class="line">        var oDiv = document.getElementById("box");</span><br><span class="line">        //点击鼠标时，原本粉色的div变大了，背景变红了</span><br><span class="line">        oDiv.onclick = function () {</span><br><span class="line">            oDiv.style.width = "200px";   //属性值要写引号</span><br><span class="line">            oDiv.style.height = "200px";</span><br><span class="line">            oDiv.style.backgroundColor = "red";   //属性名是backgroundColor，不是background-Color</span><br><span class="line">        }</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p><font color="yellow">注意事项:</font></p><ul><li>在js里写属性值时，要用引号</li><li>在js里写属性名时，是<code>backgroundColor</code>，不是CSS里面的<code>background-Color</code>。记得所有的像css属性的text-*，line-*、backgroun-*等在js中都写成驼峰</li></ul></li></ul></li><li><p>onload事件</p><ul><li><p>当页面加载文本和图片完毕后,触发onload事件</p></li><li><p>有一点我们要知道：<strong>js的加载是和html同步加载的</strong>。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。</p><p>建议是：整个页面上所有元素加载完毕在执行js内容。所以，window.onload可以预防使用标签在定义标签之前。</p></li><li><p>onload事件(屏幕可视区域)</p><ul><li>```html            <meta charset="UTF-8">        <title></title>                <script type="text/javascript">        <pre><code>    // 屏幕的可视区域    window.onload = function()&#123;                // document.documentElement 获取的是html标签        console.log(document.documentElement.clientWidth);        console.log(document.documentElement.clientHeight);        // 窗口大小发生变化时，会调用此方法        window.onresize = function()&#123;                console.log(document.documentElement.clientWidth);            console.log(document.documentElement.clientHeight);        &#125;               &#125;&lt;/script&gt;</code></pre></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- onload事件(offset系列)</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;title&gt;&lt;/title&gt;</span><br><span class="line">            &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">                *&#123;</span><br><span class="line">                    padding: 0;</span><br><span class="line">                    margin: 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/style&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body style=&quot;height: 2000px&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div class=&quot;wrap&quot; style=&quot; width: 300px;height: 300px;background-color: green&quot;&gt;</span><br><span class="line">                    &lt;div id=&quot;box&quot; style=&quot;width: 200px;height: 200px;border: 5px solid red;position: absolute;top:50px;left: 30px;&quot;&gt;            </span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            window.onload = function()&#123;</span><br><span class="line">                var box = document.getElementById(&#x27;box&#x27;)</span><br><span class="line">                /*</span><br><span class="line">                 offsetWidth占位宽  内容+padding+border</span><br><span class="line">                 offsetHeight占位高 </span><br><span class="line">                 * offsetTop: 如果盒子没有设置定位 到body的顶部的距离,如果盒子设置定位，那么是以父辈为基准的top值</span><br><span class="line">                 * offsetLeft： 如果盒子没有设置定位 到body的左部的距离，如果盒子设置定位，那么是以父辈为基准的left值</span><br><span class="line">                 </span><br><span class="line">                 * */</span><br><span class="line">                console.log(box.offsetTop)</span><br><span class="line">                console.log(box.offsetLeft)</span><br><span class="line">                console.log(box.offsetWidth)</span><br><span class="line">                console.log(box.offsetHeight)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>onscroll事件</p><ul><li><p>```html</p><!DOCTYPE html><html>    <head>        <meta charset="UTF-8">        <title></title>        <style type="text/css">            *{padding: 0;margin: 0;}        </style>    </head>    <body style="width: 2000px;height: 2000px;">        <div style="height: 200px;background-color: red;"></div>        <div style="height: 200px;background-color: green;"></div>        <div style="height: 200px;background-color: yellow;"></div>        <div style="height: 200px;background-color: blue;"></div>        <div style="height: 200px;background-color: gray;"></div>        <div id = 'scroll' style="width: 200px;height: 200px;border: 1px solid red;overflow: auto;padding: 10px;margin: 5px 0px 0px 0px;">            <p>路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城                路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城                路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城                路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城路飞学城            </p>            <pre><code>    &lt;/div&gt;        &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function()&#123;                //实施监听滚动事件        window.onscroll = function()&#123;</code></pre><p>//                console.log(1111)<br>//                console.log(‘上’+document.documentElement.scrollTop)<br>//                console.log(‘左’+document.documentElement.scrollLeft)<br>//                console.log(‘宽’+document.documentElement.scrollWidth)<br>//                console.log(‘高’+document.documentElement.scrollHeight)</p><pre><code>        &#125;                var s = document.getElementById(&#39;scroll&#39;);                s.onscroll = function()&#123;</code></pre><p>//            scrollHeight : 内容的高度+padding  不包含边框</p><pre><code>            console.log(&#39;上&#39;+s.scrollTop)            console.log(&#39;左&#39;+s.scrollLeft)            console.log(&#39;宽&#39;+s.scrollWidth)            console.log(&#39;高&#39;+s.scrollHeight)        &#125;    &#125;    &lt;/script&gt;</code></pre></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## BOM:浏览器对象模型</span><br><span class="line"></span><br><span class="line">### 1.BOM: Browser Object Model,浏览器对象模型</span><br><span class="line"></span><br><span class="line">- 结构图</span><br><span class="line">  - ![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180529172315923-104404745.png)</span><br><span class="line">  - window对象是BOM的顶层(核心)对象,所有对象都是通过它延伸出来的,也可以成为window的子对象</span><br><span class="line">  - DOM是BOM的一部分</span><br><span class="line"></span><br><span class="line">### 2.BOM常见的内置方法和内置对象</span><br><span class="line"></span><br><span class="line">- window对象</span><br><span class="line"></span><br><span class="line">  - 弹出系统对话框</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      alert();    //不同浏览器中的外观是不一样的</span><br><span class="line">      confirm();  //兼容不好</span><br><span class="line">      prompt();   //不推荐使用</span><br></pre></td></tr></table></figure></li><li><p>打开窗口,关闭窗口</p><ul><li><p>打开窗口</p><ul><li>```html<br>window.open(url,target)//url：要打开的地址。<br>//target：新窗口的位置。可以是：_blank 、_self、 _parent 父框架。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关闭窗口</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    window.close() - 关闭当前窗口 (只能关闭用js的window.open()打开的页面，了解一下就行了)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>获取窗口宽高</p><ul><li><p>```html<br>window.innerHeight - 浏览器窗口的内部高度<br>window.innerWidth - 浏览器窗口的内部宽度 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 定时器</span><br><span class="line"></span><br><span class="line">  - setTimeOut():在指定时间后执行一次</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      /定时器 异步运行  </span><br><span class="line">      function hello()&#123;  </span><br><span class="line">      alert(&quot;hello&quot;);  </span><br><span class="line">      &#125;  </span><br><span class="line">      //使用方法名字执行方法  </span><br><span class="line">      var t1 = window.setTimeout(hello,1000);  </span><br><span class="line">      var t2 = window.setTimeout(&quot;hello()&quot;,3000);//使用字符串执行方法  </span><br><span class="line">      window.clearTimeout(t1);//去掉定时器</span><br></pre></td></tr></table></figure></li><li><p>setInterval():指定时间为周期循环执行</p><ul><li><p>```html<br>/实时刷新  时间单位为毫秒<br>var t = setInterval(‘refreshQuery()’,8000);<br>/* 刷新查询 */<br>function refreshQuery(){<br>  console.log(‘每8秒调一次’)<br>}<br>window.clearInterval(t)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- location对象</span><br><span class="line"></span><br><span class="line">  - window.location可以简写成location,location相当于浏览器的地址栏,可以将url解析成独立的片段</span><br><span class="line"></span><br><span class="line">  - 属性</span><br><span class="line"></span><br><span class="line">    - href:跳转</span><br><span class="line"></span><br><span class="line">      - 页面不存在时5秒后跳转到指定页面,可以用location</span><br><span class="line"></span><br><span class="line">      - ```html</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        </span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                location.href = &quot;http://www.baidu.com&quot;;</span><br><span class="line">            &#125;, 5000);</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击盒子时进行跳转</p></li><li><p>```html</p><body><div>smyhvae</div><script><pre><code>var div = document.getElementsByTagName(&quot;div&quot;)[0];div.onclick = function () &#123;    location.href = &quot;http://www.baidu.com&quot;;   //点击div时，跳转到指定链接</code></pre><p> //     window.open(“<a href="http://www.baidu.com&quot;,&quot;_blank&quot;/">http://www.baidu.com&quot;,&quot;_blank&quot;</a>);  //方式二</p><pre><code>&#125;</code></pre><p></script><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- location.reload()重新加载:</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  setTimeout(function(){</span><br><span class="line">           //3秒之后让网页整个刷新</span><br><span class="line">      window.location.reload();</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">  },3000)</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>hash 返回url中#后面的内容,包含#</p></li><li><p>host 主机名,包括端口</p></li><li><p>hostname 主机名</p></li><li><p>pathname url中的路径部分</p></li><li><p>protocal 协议,一般是http,https</p></li><li><p>search 查询字符串</p></li></ul></li></ul><li><p>navigator对象</p><ul><li><p>window.navigator的一些属性可以获取客户端的一些信息</p><ul><li>userAgent:系统,浏览器</li><li>platform : 浏览器支持的系统,win/mac/linux</li></ul></li><li><p>例子</p><ul><li>```html<br>console.log(navigator.userAgent);<br>console.log(navigator.platform);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- history对象</span><br><span class="line"></span><br><span class="line">  - 后退</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      history.back()</span><br><span class="line">      history.go(-1)：0是刷新</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>前进</p><ul><li>```html<br>history.forward()<br>history.go(1)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- screen对象(了解)</span><br><span class="line"></span><br><span class="line">  - 屏幕对象,不常用</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    screen.availWidth - 可用的屏幕宽度</span><br><span class="line">    screen.availHeight - 可用的屏幕高度</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><h1 id="jQuery篇"><a href="#jQuery篇" class="headerlink" title="jQuery篇"></a>jQuery篇</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="1-为什么使用jQuery"><a href="#1-为什么使用jQuery" class="headerlink" title="1.为什么使用jQuery?"></a>1.为什么使用jQuery?</h3><ul><li><p>js中window onload事件只能出现一次,如果出现多次,后面的事件会覆盖掉前面的事件</p></li><li><p>js代码容错差</p></li><li><p>简单的动画效果实现很繁琐,例如简单的动画渐变效果</p></li><li><p>jQuery的两大特点</p><ul><li>链式编程:比如 .show() 和. html()可以连写为.show().html().</li><li>隐式迭代 : 隐式对应的是显式,隐式迭代的意思是: 在方法的内部循环遍历,而不用我们自己再进行循环,简化我们的操作,方便我们调用</li></ul></li></ul><h3 id="2-什么是Jquery"><a href="#2-什么是Jquery" class="headerlink" title="2.什么是Jquery"></a>2.什么是Jquery</h3><ul><li><p>Jquery是js的一个库,封装了我们开发过程中常用的一些功能,方便我们调用,提高开发效率</p></li><li><p>js库是把我们常用的复杂功能封装到简单的方法中,我们用的时候,将库直接引入然后调用方法即可<img src="https://img2018.cnblogs.com/blog/827651/201908/827651-20190814214439879-287447194.png" alt="img"></p></li><li><p>使用步骤</p><ul><li><img src="https://img2018.cnblogs.com/blog/827651/201908/827651-20190803010126992-1481898717.png" alt="img"></li></ul></li><li><p>导入包的代码一定要放在js代码的最上面</p></li></ul><h3 id="3-入口函数"><a href="#3-入口函数" class="headerlink" title="3.入口函数"></a>3.入口函数</h3><ul><li><p>原生的js’的入口函数指的是:window.onload = function() {}</p></li><li><p>jQuery的入口函数,有以下几个写法</p><ul><li><p>写法一: 文档加载完毕,图片不加字啊的时候,可以执行这个函数</p><ul><li>```html<br>$(document).ready(function () {<pre><code>       alert(1);   })</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 写法二: 写法一的简洁版</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    $(function () {</span><br><span class="line">               alert(1);</span><br><span class="line">           });</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>写法三: 文档加载完毕,图片也加载完毕的时候,在执行这个函数</p><ul><li><p>```html<br>$(window).ready(function () {</p><pre><code>       alert(1);   })</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- jQuery入口函数与js入口函数的区别</span><br><span class="line"></span><br><span class="line">  - 书写个数不同:</span><br><span class="line">    - js的入口函数只能出现一次,出现多次会存在事件覆盖效果</span><br><span class="line">    - jQuery的入口函数&lt;可以出现任意多次,并不存在事件覆盖效果</span><br><span class="line"></span><br><span class="line">  - 执行时机不同</span><br><span class="line">    - js的入口函数是在所有的文件资源加载完成后,才执行,这些文件资源包括:页面文档,外部的js文件,外部的css文件,图片等</span><br><span class="line">    - jQuery的入口函数,是在文档加载完成后,再执行,文档加载完成指的是:DOM树加载完成后,就可以操作DOM了,不用等到所有额外部资源都加载完毕</span><br><span class="line"></span><br><span class="line">### 4.jQuery的$符号</span><br><span class="line"></span><br><span class="line">- jQuery使用$的原因:书写简洁,相对于其他字符与众不同,容易被记住,</span><br><span class="line">- Jquery占用了我们两个变量: $和JQuery.在代码中这两个变量都是一样的</span><br><span class="line"></span><br><span class="line">### 5.js中的DOM对象和jQuery对象的比较&lt;font color = yellow&gt;重点&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">- 二者的区别</span><br><span class="line"></span><br><span class="line">  - 通过Jquery获取的元素是一个jq对象数组,其中包含着原生js中的DOM对象,</span><br><span class="line"></span><br><span class="line">  - 对于这样一个div结构</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div id="app"&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class="box"&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class="box"&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>js获取元素节点方式</p><ul><li>```html<pre><code>var myBox = document.getElementById("app");           //通过 id 获取单个元素var boxArr = document.getElementsByClassName("box");  //通过 class 获取的是伪数组var divArr = document.getElementsByTagName("div");    //通过标签获取的是伪数组</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- jQuery获取这些元素节点的方式:(获取的都是数组)</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    //获取的是数组，里面包含着原生 JS 中的DOM对象。</span><br><span class="line">       　　console.log($('#app'));</span><br><span class="line">       　　console.log($('.box'));</span><br><span class="line">       　　console.log($('div'));</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>总结:jQuery就是把DOM对象重新包装一下,让其具有jQuery方法\</p></li></ul></li></ul></li><li><p>二者的相互转换</p><ul><li><p>DOM对象转换为jQuery对象</p><ul><li>```html<br>$(js对象);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- jQuery对象转为DOM对象</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    jquery对象[index];      //方式1（推荐）</span><br><span class="line">    jquery对象.get(index);  //方式2</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>jquery对象转换成了DOM对象之后,可以直接调用DOM提供的一些功能,如\</p><ul><li>```html<br>$(‘div’)[1].style.backgroundColor = ‘yellow’;<br>$(‘div’)[3].style.backgroundColor = ‘green’;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.jQuery的选择器</span><br><span class="line"></span><br><span class="line">- 分为基本选择器,层级选择器,属性选择器</span><br><span class="line"></span><br><span class="line">- 基本选择器</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    $("#id")         //id选择器</span><br><span class="line">    $("tagName")     //标签选择器</span><br><span class="line">    $(".className")  //class选择器</span><br><span class="line">    $("*")           //通用选择器</span><br><span class="line">    </span><br><span class="line">    $("div.c1")      // 交集选择器 找到有含有c1类的div标签</span><br><span class="line">    $("#id, .className, tagName") //并集选择器</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>层级选择器</p><ul><li>```html<br>$(“x y”);// x的所有后代y（子子孙孙）<br>$(“x &gt; y”);// x的所有儿子y（儿子）<br>$(“x + y”)// 找到所有紧挨在x后面的y<br>$(“x ~ y”)// x之后所有的兄弟y<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 属性选择器</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    $('[href]')       //找所有含href属性的标签</span><br><span class="line">    $('a[href]')      //找所有含href属性的a标签</span><br><span class="line">    $('a[title="luffy"]') //找所有title属性是luffy的a标签</span><br><span class="line">    $('a[title="baidu"]') //找所有title属性不是百度的a标签</span><br><span class="line">    $('a[href^="https"]') //找所有href属性以https开头的a标签</span><br><span class="line">    $('a[href$="html"]')  //找所有href属性以html结尾的a标签</span><br><span class="line">    $('a[href*="i"]')  //找所有href属性中含有i的a标签</span><br><span class="line">    $('a[href][title="luffy"]') //找所有含有href属性且title属性=luffy的a标签 </span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="7-jQuery的筛选器"><a href="#7-jQuery的筛选器" class="headerlink" title="7.jQuery的筛选器"></a>7.jQuery的筛选器</h3><ul><li><p>基本筛选器</p><ul><li>```html<br>:first // 第一个<br>:last // 最后一个<br>:eq(index)// 索引等于index的那个元素<br>:even // 匹配所有索引值为偶数的元素，从 0 开始计数<br>:odd // 匹配所有索引值为奇数的元素，从 0 开始计数<br>:gt(index)// 匹配所有大于给定索引值的元素<br>:lt(index)// 匹配所有小于给定索引值的元素<br>:not(元素选择器)// 移除所有满足not条件的标签<br>:has(元素选择器)// 根据含有某个后代筛选<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 表单筛选器</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    type筛选器</span><br><span class="line">    :text</span><br><span class="line">    :password</span><br><span class="line">    :file</span><br><span class="line">    :radio</span><br><span class="line">    :checkbox</span><br><span class="line">    :submit</span><br><span class="line">    :reset</span><br><span class="line">    :button</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>其他属性筛选器</p><ul><li>```html<br>:enabled<br>:disabled<br>:checked<br>:selected<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 8.筛选器方法</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  //找兄弟</span><br><span class="line">  $("#id").siblings();// 兄弟们，不包含自己，.siblings('#id')，可以在添加选择器进行进一步筛选</span><br><span class="line">  </span><br><span class="line">  //找弟弟</span><br><span class="line">  $("#id").next()</span><br><span class="line">  $("#id").nextAll()</span><br><span class="line">  $("#id").nextUntil("#i2") #直到找到id为i2的标签就结束查找，不包含它</span><br><span class="line">  </span><br><span class="line">  //找哥哥</span><br><span class="line">  $("#id").prev()</span><br><span class="line">  $("#id").prevAll()</span><br><span class="line">  $("#id").prevUntil("#i2")</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//找祖辈</span><br><span class="line">$("#id").parent()</span><br><span class="line">$("#id").parents()  // 查找当前元素的所有的父辈元素（爷爷辈、祖先辈都找到）</span><br><span class="line">$("#id").parentsUntil('body') // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止，这里直到body标签，不包含body标签，基本选择器都可以放到这里面使用。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//找儿子</span><br><span class="line">$("#id").children();// 儿子们</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//过滤</span><br><span class="line">$("div").first() // 获取匹配的第一个元素</span><br><span class="line">$("div").last() // 获取匹配的最后一个元素</span><br><span class="line">$("div").eq(n) // 索引值等于指定值的元素，n是索引</span><br><span class="line">$("div").not() // 从匹配元素的集合中删除与指定表达式匹配的元素</span><br><span class="line">$("div").find("p") //后代选择器，在所有div标签中找后代的p标签</span><br><span class="line">$("div").filter(".c1")  // 交集选择器，从结果集中过滤出有c1样式类的</span><br><span class="line">$("div").has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="9-jQuery绑定事件"><a href="#9-jQuery绑定事件" class="headerlink" title="9.jQuery绑定事件"></a>9.jQuery绑定事件</h3><ul><li><p>```html<br>为button按钮绑定单击事件，单机按钮弹出警告框<br>$(‘button’).click(</p><pre><code>    function () {        alert('wahaha')    }</code></pre><p>)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10.jQuery操作标签</span><br><span class="line"></span><br><span class="line">- 标签内文本操作</span><br><span class="line"></span><br><span class="line">  - html标签元素中所有的内容</span><br><span class="line"></span><br><span class="line">    ```html</span><br><span class="line">    为button按钮绑定单击事件，单机按钮弹出警告框</span><br><span class="line">    $('button').click(</span><br><span class="line">            function () {</span><br><span class="line">                alert('wahaha')</span><br><span class="line">            }</span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure><ul><li><p>text标签元素的文本内容</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取值：获取选中标签元素中的文本内容</span><br><span class="line">$('#box').text();</span><br><span class="line"></span><br><span class="line">//设置值：设置该所有的文本内容</span><br><span class="line">$('#box').text('<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span>');</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>文档标签操作</p><ul><li><p>插入标签</p><ul><li><p>append和appendTo</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//追加某元素，在父元素中添加新的子元素。子元素可以为：stirng | element（js对象） | jquery元素</span><br><span class="line">父元素.append(子元素)</span><br><span class="line"></span><br><span class="line">//追加到某元素，子元素添加到父元素</span><br><span class="line">子元素.appendTo(父元素)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//append</span><br><span class="line">var oli = document.createElement('li');</span><br><span class="line">oli.innerHTML = '哈哈哈';</span><br><span class="line">$('ul').append('<span class="tag">&lt;<span class="name">li</span>&gt;</span>1233<span class="tag">&lt;/<span class="name">li</span>&gt;</span>');</span><br><span class="line">$('ul').append(oli);</span><br><span class="line">$('ul').append($('#app'));</span><br><span class="line"></span><br><span class="line">//appendTo</span><br><span class="line">$('<span class="tag">&lt;<span class="name">li</span>&gt;</span>天王盖地虎<span class="tag">&lt;/<span class="name">li</span>&gt;</span>').appendTo($('ul')).addClass('active')</span><br></pre></td></tr></tbody></table></figure><p>注意:如果追加的jQuery对原本在文档树中,那么这些元素将从原位置上消失,简言之就是移动操作</p></li><li><p>prepend和prependTo</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 前置添加， 添加到父元素的第一个位置</span><br><span class="line">父元素.prepend(子元素)；</span><br><span class="line"></span><br><span class="line">// 前置添加， 添加到父元素的第一个位置</span><br><span class="line">子元素.prependTo(父元素)；</span><br></pre></td></tr></tbody></table></figure></li><li><p>after和insertAfter</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在匹配的元素之后插入内容 </span><br><span class="line">兄弟元素.after(要插入的兄弟元素)；</span><br><span class="line">要插入的兄弟元素.inserAfter(兄弟元素)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$('ul').after('<span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是一个h3标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span>')</span><br><span class="line">$('<span class="tag">&lt;<span class="name">h5</span>&gt;</span>我是一个h2标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span>').insertAfter('ul')</span><br></pre></td></tr></tbody></table></figure></li><li><p>before和onsertBefore</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在匹配的元素之前插入内容</span><br><span class="line">兄弟元素.before(要插入的兄弟元素)；</span><br><span class="line">要插入的兄弟元素.inserBefore(兄弟元素)；</span><br><span class="line"> </span><br><span class="line">//示例</span><br><span class="line">$('ul').before('<span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是一个h3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>')</span><br><span class="line">$('<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个h2标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>').insertBefore('ul')</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>删除标签</p><ul><li>```html<br>//删除节点后，事件也会删除（简言之，删除了整个标签）<br>$(selector).remove(); // 删除节点后，事件会保留<br>$(selector).detach(); // 清空选中元素中的所有后代节点<br>$(selector).empty(); <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 修改标签</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    // selector被替换：将所有匹配的元素替换成指定的string、js对象、jquery对象。</span><br><span class="line">    $(selector).replaceWith(content);</span><br><span class="line">    </span><br><span class="line">    // selector被替换：将所有的匹配的元素替换成p标签。</span><br><span class="line">    $('&lt;p&gt;哈哈哈&lt;/p&gt;')replaceAll(selector);</span><br><span class="line">    // replaceWith </span><br><span class="line">    $('h5').replaceWith('&lt;a href="#"&gt;hello world&lt;/a&gt;') //将所有的h5标题替换为a标签</span><br><span class="line">    $('h5').replaceWith($('#app')); //将所有h5标题标签替换成id为app的dom元素</span><br><span class="line">    </span><br><span class="line">    // replaceAll</span><br><span class="line">    $('&lt;br/&gt;&lt;hr/&gt;&lt;button&gt;按钮&lt;/button&gt;').replaceAll('h4')</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>克隆标签</p><ul><li>```html<br>$(‘button’).click(function() { // 1.clone()：克隆匹配的DOM元素<br> // 2.clone(true)：元素以及其所有的事件处理并且选中这些克隆的副本(简言之，副本具有与真身一样的事件处理能力)<br>  $(this).clone(true).insertAfter(this);<br>})<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 属性操作</span><br><span class="line"></span><br><span class="line">  - atter()设置属性值或者获取值</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>//获取值：attr()设置一个属性值的时候 只是获取值<br>$(‘div’).attr(‘id’)<br>$(‘div’).attr(‘class’)</li></ul><p>//设置值<br>$(‘div’).attr(‘class’,’box’) //设置一个值<br>$(‘div’).attr({name:’hahaha’,class:’happy’}) //设置多个值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- removeAttr()移除属性</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>//删除单个属性<br>$(‘#box’).removeAttr(‘name’);<br>$(‘#box’).removeAttr(‘class’);</p><p>//删除多个属性<br>$(‘#box’).removeAttr(‘name class’);</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prop()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>// 查看属性<br>$(selector).prop(property)</p><p>// 设置属性<br>$(selector).prop(property,value)</p><p>// 设置多个属性<br>$(selector).prop({property:value, property:value,…})</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- class类属性</span><br><span class="line"></span><br><span class="line">  - addClass添加类名</span><br><span class="line"></span><br><span class="line">    ```html</span><br><span class="line">    // 为每个匹配的元素添加指定的类名。</span><br><span class="line">    $('div').addClass("box");//追加一个</span><br><span class="line">    $('div').addClass("box box2");//追加多个</span><br></pre></td></tr></tbody></table></figure></li><li><p>removeClass移除类名</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 从所有匹配的元素中删除全部或者指定的类。</span><br><span class="line">$('div').removeClass('box')；//移除box类</span><br><span class="line">$('div').removeClass();//移除全部的类</span><br></pre></td></tr></tbody></table></figure></li><li><p>toggleClass类的切换</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果存在（不存在）就删除（添加）一个类。</span><br><span class="line">$('div').toggleClass('box')</span><br><span class="line"></span><br><span class="line">$('span').click(function(){</span><br><span class="line">    //动态的切换class类名为active</span><br><span class="line">    $(this).toggleClass('active')</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>val表单控制Value属性</p><ul><li>```html<br>// 获取值：用于表单控件中获取值，比如input textarea select等等<br>$(selector).val()// 设置值：<br>$(‘input’).val(‘设置了表单控件中的值’)；<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- css样式</span><br><span class="line"></span><br><span class="line">  ```html</span><br><span class="line">  // css(直接修改css的属性来修改样式)</span><br><span class="line">  $("div").css('color'); //获取</span><br><span class="line">  </span><br><span class="line">  $("p").css("color", "red"); //设置</span><br><span class="line">  $("p").css({"color":"red","background-color":"yello"}); // 设置多个</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>盒子样式属性</p><ul><li><p>内容:宽度(width)和高度(height)</p></li><li><p>内容+padding:宽度(innerWidth) 高度(innerHeight)</p></li><li><p>内容+padding+border:宽度(outerWidth) 高度(outerHeight)</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 外部宽</span><br><span class="line"> .outerWidth() //获取第一个匹配元素 ：内容+padding+border的宽</span><br><span class="line"> .outerWidth(true) //获取第一个匹配元素：内容+padding+border+margin的宽</span><br><span class="line"></span><br><span class="line"> .outerWidth(value) //设置多个，调整的是“内容”的宽</span><br><span class="line"></span><br><span class="line">//外部高</span><br><span class="line"> .outerHeight() //第一个匹配元素：获取内容+padding+border的高</span><br><span class="line"> .outerHeight(true) //第一个匹配元素：获取内容+padding+border+margin的高</span><br><span class="line"></span><br><span class="line"> .outerHeight( value ) //设置多个，调整的是“内容”的高</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>滚动条距离属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 水平方向</span><br><span class="line">.scrollLeft()      //获取</span><br><span class="line">.scrollLeft( value )//设置</span><br><span class="line"></span><br><span class="line">// 垂直方向</span><br><span class="line">.scrollTop() //获取</span><br><span class="line">.scrollTop( value ) //设置</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="jQuery动画效果"><a href="#jQuery动画效果" class="headerlink" title="jQuery动画效果"></a>jQuery动画效果</h2><h3 id="1-显示动画"><a href="#1-显示动画" class="headerlink" title="1.显示动画"></a>1.显示动画</h3><ul><li><p>无参数,让指定的元素显现出来,底层通过display:block实现</p><ul><li><p>```html<br>$(“div”).show();</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过控制元素的宽高,透明度,display属性,逐渐显示,例如3秒后显示完毕</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    $('div').show(3000);</span><br></pre></td></tr></tbody></table></figure></li><li><p>参数</p><ul><li>slow 慢:600ms</li><li>normal 正常 400ms</li><li>fast 快:200ms</li></ul></li><li><p>动画执行完毕后立即执行回调函数</p><ul><li>```html<br>//show(毫秒值，回调函数;<br>   $(“div”).show(5000,function () {<pre><code>   alert("动画执行完毕！");</code></pre>   );<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.隐藏动画</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">      $(selector).hide();</span><br><span class="line">  </span><br><span class="line">      $(selector).hide(1000); </span><br><span class="line">  </span><br><span class="line">      $(selector).hide("slow");</span><br><span class="line">  </span><br><span class="line">      $(selector).hide(1000, function(){});</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><h3 id="3-开关式显示隐藏动画"><a href="#3-开关式显示隐藏动画" class="headerlink" title="3.开关式显示隐藏动画"></a>3.开关式显示隐藏动画</h3><ul><li>```html<br>$(‘#box’).toggle(3000,function(){});<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显示和隐藏的拉回切换采用的是toggle()方法,就是先执行show(),再执行hide()</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">      $('#btn').click(function(){</span><br><span class="line">              $('#box').toggle(3000,function(){</span><br><span class="line">                  $(this).text('盒子出来了');    </span><br><span class="line">                  if ($('#btn').text()=='隐藏') {</span><br><span class="line">                      $('#btn').text('显示');    </span><br><span class="line">                  }else{</span><br><span class="line">                      $('#btn').text('隐藏');    </span><br><span class="line">                  }</span><br><span class="line">              });</span><br><span class="line">          })</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="4-滑入和滑出"><a href="#4-滑入和滑出" class="headerlink" title="4.滑入和滑出"></a>4.滑入和滑出</h3><ul><li><p>滑入,下拉动画,显示元素</p><ul><li>```html<br>$(selector).slideDown(speed, 回调函数);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 滑出,上拉动画,隐藏元素</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    $(selector).slideUp(speed, 回调函数);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>滑入滑出动画效果切换</p><ul><li>```<br>$(selector).slideToggle(speed, 回调函数);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.淡入淡出效果</span><br><span class="line"></span><br><span class="line">- 淡入动画效果,</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    $(selector).fadeIn(speed, callback);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>淡出动画效果</p><ul><li>```<br>$(selector).fadeOut(1000);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 淡入淡出动画效果来回切换</span><br><span class="line"></span><br><span class="line">  - ```HTML</span><br><span class="line">    $(selector).fadeToggle('fast', callback);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="6-自定义动画"><a href="#6-自定义动画" class="headerlink" title="6.自定义动画"></a>6.自定义动画</h3><ul><li><p>```html<br>$(selector).animate({params}, speed, callback);</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 作用:执行一组CSS属性的自定义动画</span><br><span class="line"></span><br><span class="line">  - 第一个参数:要执行动画的CSS属性(必选)</span><br><span class="line">  - 第二个参数:执行动画的时长:可选</span><br><span class="line">  - 第三个动画:动画执行完毕后,立即执行的回调函数(可选)</span><br><span class="line"></span><br><span class="line">### 7.停止动画</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  $(selector).stop(true, false);</span><br></pre></td></tr></tbody></table></figure></li><li><p>参数说明</p><ul><li>第一个参数:true表示后续动画不执行,false表示后续动画执行</li><li>第二个参数:true表示立即执行完成当前动画,false表示立即停止当前动画</li><li>如果参数都不写,默认两个参数都是false,实际常用的是stop(),</li></ul></li></ul><h2 id="jQuery的事件操作"><a href="#jQuery的事件操作" class="headerlink" title="jQuery的事件操作"></a>jQuery的事件操作</h2><h3 id="1-绑定事件"><a href="#1-绑定事件" class="headerlink" title="1.绑定事件"></a>1.绑定事件</h3><ul><li><p>```html<br>bind(type,data,fn)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明</span><br><span class="line"></span><br><span class="line">  - type(string) :事件类型</span><br><span class="line"></span><br><span class="line">  - data(Object):可选,作为event.data属性值传递给事件对象的额外数据对象</span><br><span class="line"></span><br><span class="line">  - fn(Function) : 绑定到每个匹配元素的事件上面的处理函数</span><br><span class="line"></span><br><span class="line">  - 示例:当每个p标签被点击时,弹出其文本</span><br><span class="line"></span><br><span class="line">    - ```html</span><br><span class="line">      $("p").bind("click", function(){</span><br><span class="line">        alert( $(this).text() );</span><br><span class="line">      });</span><br></pre></td></tr></tbody></table></figure><ul><li><p>示例:事件处理之前传递一些附加的数据</p><ul><li><p>```html<br>function handler(event) {<br>//event.data 可以获取bind()方法的第二个参数的数据<br>  alert(event.data.foo);<br>}<br>$(“p”).bind(“click”, {foo: “bar”}, handler)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 常见事件</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    click(function(){...})</span><br><span class="line">    hover(function(){...})</span><br><span class="line">    blur(function(){...})</span><br><span class="line">    focus(function(){...})</span><br><span class="line">    change(function(){...}) //内容发生变化，input，select等</span><br><span class="line">    keyup(function(){...})  </span><br><span class="line">    mouseover/mouseout</span><br><span class="line">    mouseenter/mouseleave</span><br><span class="line">    mouseover事件是如果该标签有子标签，那么移动到该标签或者移动到子标签时会连续触发，mouseenter事件不管有没有子标签都只触发一次，表示鼠标进入这个对象</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过返回false来取消默认的行为来阻止事件起泡</p><ul><li>```html<br>$(“form”).bind(“submit”, function() { return false; })<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过event.preventDefault()方法来阻止事件起泡</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    $("form").bind("submit", function(event){</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="2-解绑事件"><a href="#2-解绑事件" class="headerlink" title="2.解绑事件"></a>2.解绑事件</h3><ul><li>```html<br>unbind(type,fn);<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 描述:bind()的反向操作,从每一个匹配的元素中删除绑定的事件,如果没有参数,则删除所有的绑定事件,如果把绑定时传递的处理函数作为第二个参数,则只有这个特定的事件处理函数会被删除</span><br><span class="line"></span><br><span class="line">- 参数说明</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    type (String) : (可选) 事件类型</span><br><span class="line">    fn(Function) : (可选) 要从每个匹配元素的事件中反绑定的事件处理函数</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="3-补充一次性事件"><a href="#3-补充一次性事件" class="headerlink" title="3.补充一次性事件"></a>3.补充一次性事件</h3><ul><li><p>```html<br>one(type,data,fn)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 描述:为每一个匹配的元素的特定事件,像(click)绑定一个一次性的事件处理函数,在每个对象上,这个事件处理函数只会被执行一次,其他规则与bind()函数相同</span><br><span class="line"></span><br><span class="line">- 参数说明</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    type (String) : 事件类型</span><br><span class="line">    data (Object) : (可选) 作为event.data属性值传递给事件对象的额外数据对象</span><br><span class="line">    fn (Function) : 绑定到每个匹配元素的事件上面的处理函数</span><br></pre></td></tr></tbody></table></figure></li><li><p>示例:当所有段落被第一次点击的时候,显示所有其文本</p><ul><li><p>```html<br>$(“p”).one(“click”, function(){<br>//只有第一次点击的时候才会触发，再次点击不会触发了<br>  alert( $(this).text() );<br>});</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4.事件委托(事件代理)</span><br><span class="line"></span><br><span class="line">- 原理:利用冒泡的原理,把事件加到父级上,触发执行效果</span><br><span class="line"></span><br><span class="line">- 作用:</span><br><span class="line"></span><br><span class="line">  - 性能要好</span><br><span class="line">  - 针对新创新的元素,直接可以拥有事件</span><br><span class="line"></span><br><span class="line">- 事件源:</span><br><span class="line"></span><br><span class="line">  - 跟this作用一样(他不用看指向问题,谁操作的就是谁),event对象下的</span><br><span class="line"></span><br><span class="line">- 使用情景</span><br><span class="line"></span><br><span class="line">  - 为DOM中的很多元素绑定的相同事件</span><br><span class="line"></span><br><span class="line">  - 为DOM中尚不存在的元素绑定事件</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li class="luffy"&gt;路飞&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;路飞&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;路飞&lt;/li&gt;</span><br><span class="line">                </span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script src="jquery-3.2.1.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type="text/javascript"&gt;</span><br><span class="line">    $(document).ready(function(){</span><br><span class="line">        </span><br><span class="line">        //通过on()方法</span><br><span class="line">         $('ul').on('click','#namei,.luffy',function(){</span><br><span class="line">            console.log(this);</span><br><span class="line">           })</span><br><span class="line">                </span><br><span class="line">       //未来追加的元素 </span><br><span class="line">        $('ul').append('&lt;a id="namei"&gt;娜美&lt;/a&gt;')</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>语法:在选定的元素上绑定一个或者多个事件处理函数</p><ul><li><pre><code class="html">on(type,selector,data,fn);</code></pre></li><li><p>参数说明</p><ul><li>events(String) : 一个或多个空格分隔的事件类型</li><li>selector(String) : 一个选择器字符串,用于过滤出被选中的元素中能触发事件的后代元素</li><li>data:当一个事件被触发时,要传递给事件处理函数的event.data.</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2021/09/29/git%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/09/29/git%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git笔记"><a href="#Git笔记" class="headerlink" title="Git笔记"></a>Git笔记</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>Git是分布式管理仓库，而SVN是集中式（CVS）管理的代表。CVS是保存文件修改的历史记录（文件变更的列表），Git是记录文件及其修改的快照并存储相应索引。</p><h2 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h2><h3 id="2-1-安装配置"><a href="#2-1-安装配置" class="headerlink" title="2.1 安装配置"></a>2.1 安装配置</h3><h4 id="2-1-1-安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。"><a href="#2-1-1-安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。" class="headerlink" title="2.1.1 安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。"></a>2.1.1 安装好Git后先全局配置用户信息：用户名、邮箱。如果在某个项目中需要使用其他用户，可以在项目根目录下去掉’global’单独配置。</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "John Doe"</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></tbody></table></figure><h4 id="2-1-2-检查配置信息"><a href="#2-1-2-检查配置信息" class="headerlink" title="2.1.2 检查配置信息"></a>2.1.2 检查配置信息</h4><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></tbody></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 git config &lt;key&gt;： 来检查 Git 的某一项配置<br>可以根据key修改以上的值：git config &lt;key&gt; &lt;value&gt;  </p><h2 id="1-把本地代码推到远程仓库"><a href="#1-把本地代码推到远程仓库" class="headerlink" title="1. 把本地代码推到远程仓库"></a>1. 把本地代码推到远程仓库</h2><p>1.1 上github新建仓库，不选新建README，懒得再解决冲突<br>1.2 （先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库，记得创建.gitignore文件忽略上传某些文件。  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init  </span><br></pre></td></tr></tbody></table></figure><p>1.3 把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .  </span><br></pre></td></tr></tbody></table></figure><p>1.4 用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m 'first commit'  </span><br></pre></td></tr></tbody></table></figure><p>1.5 关联到远程库  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你的远程库地址  </span><br></pre></td></tr></tbody></table></figure><p>1.6 获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master  </span><br></pre></td></tr></tbody></table></figure><p>1.7 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。  </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master  </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6入门学习</title>
      <link href="/2021/09/29/es6%E5%88%9D%E5%A7%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/29/es6%E5%88%9D%E5%A7%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6标准入门学习总结"><a href="#ES6标准入门学习总结" class="headerlink" title="ES6标准入门学习总结"></a>ES6标准入门学习总结</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h2 id="2-let和const"><a href="#2-let和const" class="headerlink" title="2. let和const"></a>2. let和const</h2><p>const申明的常量只是在内存中的地址不变，指针不变。如果常量是个复杂类型，依然可以修改。如果把一个常量再次赋值给新变量，再覆盖新变量，常量是不会修改的。  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = { <span class="attr">age</span>: <span class="number">29</span> };</span><br><span class="line"><span class="keyword">let</span> b =  a;</span><br><span class="line">b.age = <span class="number">30</span>;  <span class="comment">// a.age === b.age === 30</span></span><br><span class="line">b = <span class="number">31</span>;  <span class="comment">// a依然是{ age: 30 }</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-变量解构赋值"><a href="#3-变量解构赋值" class="headerlink" title="3. 变量解构赋值"></a>3. 变量解构赋值</h2><h2 id="4-字符串扩展"><a href="#4-字符串扩展" class="headerlink" title="4. 字符串扩展"></a>4. 字符串扩展</h2><h3 id="4-1-ES6前常用的方法"><a href="#4-1-ES6前常用的方法" class="headerlink" title="4.1 ES6前常用的方法"></a>4.1 ES6前常用的方法</h3><p>4.1.1 String.fromCharCode(Unicode1,Unicode2,…,Unicoden)是String静态方法，参数是至少一个Unicode码，返回所有参数对应的字符组成的字符串。<br>4.1.2 stringObject.indexOf(searchvalue[,fromindex])默认从首字符开始检索，返回某个指定的字符串值在字符串中首次出现的位置，没有返回-1。<br>4.1.3 stringObject.lastIndexOf(searchvalue,fromindex)  </p><p>字符串新增方法  </p><p>正则扩展  </p><p>数值的扩展  </p><p>函数的扩展  </p><p>数组的扩展  </p><p>对象的扩展  </p><p>对象新增的方法  </p><p>Symbol  </p><p>set和map  </p><p>Proxy  </p><p>Reflect  </p><p>Promise  </p><p>Iterator和for…of  </p><p>Generatore  </p><p>Generator 的异步应用  </p><p>async  </p><p>class</p><p>  ES6之前实现一个类一般是通过工厂函数，修改原型链实现类的继承。ES6提供classAPI，使用extends继承。<br>  子类必须在constructor中首先调用super否则会报错(新建子类实例时)，因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br>  ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this<br>  super表示父类的构造函数，但是返回的是子类<br>  类中无this，只有实例才有</p><p>super指向父类（不是实例哦），constuctor默认返回的是实例，也可手动返回其他对象<br>如果父类constructor有参数，子类必须调用super，并且传入指定参数：既子类的constructor的参数必须包括父类constructor的参数，且子类必须调用super传入这些参数  </p><h2 id="22-class的继承"><a href="#22-class的继承" class="headerlink" title="22. class的继承"></a>22. class的继承</h2><p>  class语法本身是es5构造函数的语法上塘，定义的类的方法(非静态方法)本身是在原型链上添加方法  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">somemethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">    <span class="function"><span class="title">othermethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Object</span>.asign(A.prototype,{</span><br><span class="line">    <span class="function"><span class="title">somemethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">    <span class="function"><span class="title">othermethord</span>(<span class="params"></span>)</span> {}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>  constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor默认返回当前类的实例(this)，也可以返回指定上下文</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{}</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  如果有父类，还必须在constructor中调用super  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.x = x</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span> {</span><br><span class="line">        <span class="built_in">super</span>(x)</span><br><span class="line">        <span class="built_in">this</span>.y = y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  在new一个类时，先调用constructor方法，如果是子类，必须在constructor内先调用super(接受全部父类需要的参数)，先创建父类上下文，再创建子类上下文<br>  class内的方法不需要加function,可以在constructor中绑定this或使用箭头函数，否则经过赋值后的方法会改变this  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">text</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> {say} = <span class="keyword">new</span> Parent()</span><br><span class="line">say() <span class="comment">// Uncaught TypeError: Cannot read property 'firstname' of undefined</span></span><br><span class="line"><span class="keyword">const</span> {text} = Parent</span><br><span class="line">text() <span class="comment">// Uncaught TypeError: Cannot read property 'firstname' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.say = <span class="built_in">this</span>.say.bind(<span class="built_in">this</span>)</span><br><span class="line">    }</span><br><span class="line">    say = <span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> username = <span class="string">'nothing'</span></span><br><span class="line">    <span class="keyword">static</span> text1 = <span class="function">()=&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.username)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> {say} = <span class="keyword">new</span> Parent()</span><br><span class="line">say() <span class="comment">// 'Parent'</span></span><br><span class="line"><span class="keyword">const</span> {text} = Parent</span><br><span class="line">text() <span class="comment">// 'nothing'wqwqsdfsdf</span></span><br></pre></td></tr></tbody></table></figure><p>  第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><p>module  </p><p>module的加载实现  </p><p>编程风格  </p><p>读懂规格  </p><p>异步遍历器  </p><p>ArrayBuffer  </p><p>Decorator</p><p>作用域  </p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在函数、模块外申明的变量全局都可以访问。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inde.html</span></span><br><span class="line"><span class="comment">// 重点在type，如果是module，这段脚本就是es6module</span></span><br><span class="line">...</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>; <span class="comment">// 全局作用域</span></span><br><span class="line">b=<span class="number">13</span>; <span class="comment">// 使用效果如上，他实际上是挂到window上，可以被删除，但是a却不能</span></span><br></pre></td></tr></tbody></table></figure><h3 id="函数-局部作用域"><a href="#函数-局部作用域" class="headerlink" title="函数/局部作用域"></a>函数/局部作用域</h3><p>在函数内申明的变量只能在函数内访问（可以访问上一级变量；module也是函数）</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>this  </p><h3 id="块状作用域"><a href="#块状作用域" class="headerlink" title="块状作用域"></a>块状作用域</h3><p>{}中的代码；let、const</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for…in…针对object（array是object，arr.name=122,也会被遍历）,for针对array，for…of…都可以  </p><h2 id="帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）"><a href="#帮你彻底搞懂JS中的prototype、-proto-与constructor（图解）" class="headerlink" title="帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）"></a><a href="https://blog.csdn.net/cc18868876837/article/details/81211729">帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）</a></h2><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>普通函数的this，谁调用只想谁，非严格模式找不到就指向window。箭头函数是绑定的父级的作用域，如果父级也是箭头函数，那就继续晚上找。obj={fn(){}},这是obj={fn:fucntion(){}}的简写，而不是箭头函数。  </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结常用的一些类库</title>
      <link href="/2021/09/29/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"/>
      <url>/2021/09/29/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="总结常用的一些类库"><a href="#总结常用的一些类库" class="headerlink" title="总结常用的一些类库"></a>总结常用的一些类库</h1><h2 id="1-JS模板引擎"><a href="#1-JS模板引擎" class="headerlink" title="1. JS模板引擎"></a>1. JS模板引擎</h2><p>1.1 <a href="https://handlebarsjs.com/zh/">handlebars.js</a><br>1.2 <a href="https://ejs.bootcss.com/">ejs.js</a>  </p><blockquote><p>服务端和客户端都可以，捕获异常准确调试方便  </p></blockquote><p>1.3 <a href="https://aui.github.io/art-template/zh-cn/index.html">art-template.js</a>  </p><blockquote><p>分客户端（兼容IE8+，IE8需要加补丁），node端：express、koa，webpack端  </p></blockquote><h2 id="2-JS库"><a href="#2-JS库" class="headerlink" title="2. JS库"></a>2. JS库</h2><h3 id="1-jQuery，zepto-js"><a href="#1-jQuery，zepto-js" class="headerlink" title="1. jQuery，zepto.js"></a>1. <a href="https://jquery.com/">jQuery</a>，<a href="http://www.zeptojs.cn/">zepto.js</a></h3><blockquote><p>jQuery兼容许多老浏览器版本，1.x兼容到IE6，2.x只是相较于1.x移除了IE6/7/8的兼容，3.x相较于2.x增加了许多新特性。可以参照<a href="https://www.hangge.com/blog/cache/detail_2228.html">jQuery - 不同版本的差异汇总（版本选择建议</a>、<a href="https://www.hangge.com/blog/cache/detail_2235.html">jQuery - jQuery3的新特性汇总（附样例）</a><br>zepto相较于jQuery，则是针对Chrome和safria，更加轻量<br><a href="https://jqueryvalidation.org/documentation/">jquery-validation</a>表单验证插件。(jQuery, tested with 1.7.2, 1.8.3, 1.9.1, 1.11.1, 3.1.1)</p></blockquote><h3 id="2-backbone-js"><a href="#2-backbone-js" class="headerlink" title="2. backbone.js"></a>2. <a href="http://www.zeptojs.cn/">backbone.js</a></h3><blockquote><p>MVC前端框架<a href="https://github.com/the5fire/backbonejs-learning-note">Backbone.js入门教程第二版</a>  </p></blockquote><h3 id="3-popper-js"><a href="#3-popper-js" class="headerlink" title="3. popper.js"></a>3. <a href="https://popper.js.org/">popper.js</a></h3><blockquote><p>元素定位类库，许多UI框架都在使用。</p></blockquote><h2 id="koa2"><a href="#koa2" class="headerlink" title="koa2"></a>koa2</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>koa-views,koa-swig,ejs,handlebars,art-template<br>模板引擎也分服务端和客户端，node端得搭配koa-views、koa-swig、koa-ejs等使用。这里只讲<a href="mailto:koa-views@6.2.1">koa-views@6.2.1</a>使用中路径问题,其内部使用get-paths(path, relPath, extension)这个库解析路径。</p><p><img src="./images/koa2_demo_koa-views_path.jpg" alt="项目路径"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">"@koa/router"</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">"koa-views"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// views方法第一个参数就是get-paths接收的第一个参数，还可以是绝/相对路径，extension就是第三个参数。路由中render的第一个参数就是get-paths第二个参数(这是个坑，不是路径,可以有后缀名)。解析到文件会找下面的index文件。</span></span><br><span class="line">app.use(views(<span class="string">'views'</span>, {</span><br><span class="line">    <span class="attr">extension</span>: <span class="string">"ejs"</span></span><br><span class="line">}));</span><br><span class="line">router.get(<span class="string">"/users"</span>, <span class="keyword">async</span> (ctx, next) =&gt; {</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">"users"</span>, {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">"用户管理"</span></span><br><span class="line">    })</span><br><span class="line">});</span><br><span class="line">router.get(<span class="string">"/users/admin"</span>, <span class="keyword">async</span> (ctx, next) =&gt; {</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'users/admin'</span>, {</span><br><span class="line">        <span class="attr">title</span>: <span class="string">"admin"</span></span><br><span class="line">    })</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>ejs  </p><blockquote><p>服务端：npm i ejs<br>客户端：Go to the <a href="https://github.com/mde/ejs/releases/latest">Latest Release</a>, download<br><code>./ejs.js</code> or <code>./ejs.min.js</code>. Alternately, you can compile it yourself by cloning<br>the repository and running <code>jake build</code> (or <code>$(npm bin)/jake build</code> if jake is<br>not installed globally).也可以<code>npx jake buld</code></p></blockquote><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>koa-static，koa-static-cache  </p><h2 id="3-打包工具"><a href="#3-打包工具" class="headerlink" title="3 打包工具"></a>3 打包工具</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a><a href="https://www.webpackjs.com/">webpack</a></h3><h3 id="parceljs"><a href="#parceljs" class="headerlink" title="parceljs"></a><a href="https://parceljs.org/">parceljs</a></h3><h3 id="gulp-v4-x"><a href="#gulp-v4-x" class="headerlink" title="gulp v4.x"></a><a href="https://www.gulpjs.com.cn/">gulp v4.x</a></h3><h3 id="Rollup-js"><a href="#Rollup-js" class="headerlink" title="Rollup.js"></a><a href="https://www.rollupjs.com/">Rollup.js</a></h3><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h3 id="dotenv"><a href="#dotenv" class="headerlink" title="dotenv"></a><a href="https://www.npmjs.com/package/dotenv">dotenv</a></h3><p>识别文件(.env)中的变量，并添加到process.env中  </p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a><a href="https://github.com/demopark/sequelize-docs-Zh-CN">sequelize</a></h4><p>Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能.</p><h3 id="node端生成、操作DOMjsdom"><a href="#node端生成、操作DOMjsdom" class="headerlink" title="node端生成、操作DOMjsdom"></a>node端生成、操作DOM<a href="https://www.npmjs.com/package/jsdom">jsdom</a></h3><h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><h3 id="tinymce（无依赖）"><a href="#tinymce（无依赖）" class="headerlink" title="tinymce（无依赖）"></a><a href="https://www.tiny.cloud/docs/">tinymce</a>（无依赖）</h3><h3 id="ckeditor（无依赖）"><a href="#ckeditor（无依赖）" class="headerlink" title="ckeditor（无依赖）"></a><a href="https://ckeditor.com/">ckeditor</a>（无依赖）</h3><h3 id="draft-js（react，facebook开源）"><a href="#draft-js（react，facebook开源）" class="headerlink" title="draft.js（react，facebook开源）"></a><a href="https://draftjs.org/docs/getting-started">draft.js</a>（react，facebook开源）</h3><h3 id="Lin-CMS"><a href="#Lin-CMS" class="headerlink" title="Lin CMS"></a><a href="http://doc.cms.7yue.pro/">Lin CMS</a></h3><p>可以用koa、flask、spring-boot搭建  </p><h2 id="4-popper-js弹窗"><a href="#4-popper-js弹窗" class="headerlink" title="4 popper.js弹窗"></a>4 <a href="https://popper.js.org/">popper.js弹窗</a></h2><h2 id="5-网站运行状态管理"><a href="#5-网站运行状态管理" class="headerlink" title="5 网站运行状态管理"></a>5 网站运行状态管理</h2><p>不过一般来说有后台监视系统</p><ol><li><a href="https://github.com/juliomrqz/statusfy">statusfy</a>  </li><li><a href="https://github.com/CachetHQ/Cachet">Cachet</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劝退指南</title>
      <link href="/2021/09/29/%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/"/>
      <url>/2021/09/29/%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Javascript模块化编程（一）：模块的写法</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>图片分为banner（大图）、普通图片（需要压缩）、小图和图标(可以制作雪碧图、base64等)，所以都需要单独建目录针对处理。</p></li><li><p>样式分为公共和模块独有，公共部分又分common.less、variable.less、reset.less，其中common.less又可以单独拆分：比如常见的容器、整体布局可以分为一类，重置UI框架的样式可以分为一类。然后按序引入一个文件。variable.less可以使用插件。  </p></li><li><p>API可以根据需要分为url和method，配制成对象。常用的也可以封装成方法。  </p></li><li><p>项目中使用的正则全部统一管理，表单验证规则、提示语等根据UI框架设置成json。  </p></li><li><p>常用方法放到util目录。  </p></li><li><p>assets：静态文件目录，可以使用webpack’卓一些处理；static：静态文件，不用做处理；  </p></li><li><p>常用的一些前后端对接的变量：数据字典，单独存储。</p></li><li><p>先讲清楚需求，客户端兼容性，移动端还是PC端，客户端对数据持久化的程度要求，路由切换动效，全局或者局部loading，默认字体及其大小颜色、主题色等。后台数据缺省值，数据模型、名称尽量统一。</p></li><li><p>写详细设计：需求文档中的需求说明、原型、前端交互及数据交互的流程图、接口文档（请求体：报文、method、request，响应体：报文、data、status、message），需求及原型评审、UI评审、详设评审、接口文档评审。  </p></li><li><p>组件一般只解决交互、数据传递、数据通用转换等需求，页面才处理数据请求分发等业务。</p></li><li><p>约定大于大于配置，不要在某些问题上纠结，好的习惯变成约定以配置实现。  </p></li><li><p>与后台约定好接口的status、message，数据不要嵌套太深。  </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6入门学习</title>
      <link href="/2021/09/29/%E6%AD%A3%E5%88%99%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/09/29/%E6%AD%A3%E5%88%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p><p><a href="https://juejin.cn/post/6844903487155732494">JS 正则表达式完整教程（略长）</a></p><p><a href="https://cloud.tencent.com/developer/chapter/13619">腾讯云文档</a></p><h2 id="1-1-匹配标志"><a href="#1-1-匹配标志" class="headerlink" title="1.1 匹配标志"></a>1.1 匹配标志</h2><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>g</td><td>全局搜索</td></tr><tr><td>m</td><td>多行匹配</td></tr><tr><td>i</td><td>忽略大小写</td></tr><tr><td>y</td><td>执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始(lastIndex)</td></tr><tr><td>s</td><td>允许<code>.</code> 匹配换行符</td></tr><tr><td>u</td><td>使用 unicode 码的模式进行匹配</td></tr></tbody></table><ul><li>正则对象都有个 lastIndex 属性，只读（但是 js 没有严格语法限制，可以修改），只有正则使用了 global 标志才会在匹配成功是修改 lastIndex 的值，失败置 0。使用 sticky 标志，只会从正则的 lastIndex 开始匹配，但是不会修改它的值。</li><li>多行匹配只有在字符串中有换行符时才有意义，有换行符时^、$表示每行开头结尾，如果不使用^或$那么也没必要使用 m 标志。</li><li>除了 i，其他基本没使用过。</li></ul><h2 id="1-2-匹配模式"><a href="#1-2-匹配模式" class="headerlink" title="1.2 匹配模式"></a>1.2 匹配模式</h2><p>匹配字符或者匹配位置。</p><h2 id="1-3-RegExp-和-String-的一些常用方法"><a href="#1-3-RegExp-和-String-的一些常用方法" class="headerlink" title="1.3 RegExp 和 String 的一些常用方法"></a>1.3 RegExp 和 String 的一些常用方法</h2><p>String：</p><blockquote><p>replace<br>search<br>match<br>matchAll<br>split</p></blockquote><p>RegExp：</p><blockquote><p>test<br>exec<br>compile</p></blockquote><p>正则实际匹配结果看 match 和 matchAll，test 只是判断字符串是否满足正则要求。<br>search 相当于 indexOf 于 Array，找到满足正则的第一个字符集首字符位置，否则返回-1。<br>exec 开启 g 或 y 每次调用会修改 lastIndex。<br>matchAll 返回的是迭代器。</p><p>重点说 replace：str.replace(regexp|substr, newSubStr|function)</p><blockquote><p>第一个参数：可以使正则，会处理全部匹配的字符。可以使字符串，只处理第一个相等字符。<br>第二个参数：可以使特殊字符串，$&amp;表示被整个正则匹配到的字符，可以修饰字符串；$n 表示每个子表达式匹配的字符，可以重新组合或者提取字符串（子表达式没匹配到的会被忽略）；$`、$‘表示匹配字符左边、右边全部类容，可以修饰字符串。可以使函数，参数是[match 的字符，…子表达式匹配的结果,位置，输入值]，返回值替换匹配字符，如果开启 g 或 m 会多次调用。</p></blockquote><table><thead><tr><th>变量名</th><th>代表值</th></tr></thead><tbody><tr><td>$$</td><td>插入一个 “$”</td></tr></tbody></table><h2 id="1-4-问题"><a href="#1-4-问题" class="headerlink" title="1.4 问题"></a>1.4 问题</h2><ol><li><p>一道面试题<br>![一道面试题][reg_g]</p><details>  <summary><font color="#56b6a7">答案</font></summary>  <pre><code>  truetruefalsetrue// 在设置g或y模式，RegExp 对象是有状态的。他们会将上次成功匹配后的位置记录在 lastIndex 属性中。// 全局匹配会记录上次匹配到的位置，然后下一次从上一次的位置开始匹配，失败时会重置lastIndex为0。  </code></pre></details></li><li><p>一道面试题：使用正则实现 String.trim()</p><details>  <summary><font color="#56b6a7">答案</font></summary>  <pre><code>  String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")}  </code></pre></details></li><li><p>实现一个正则：不能以空白字符开头和结束，至少一个字符</p><details>  <summary><font color="#56b6a7">我的</font></summary>  <pre><code>   /^\S(.*\S)?$/ /^\S{1}$|^\S+.*\S+$/g  </code></pre></details></li><li><p>一道面试题：使用正则实现 String.trim()</p></li><li><p>不同系统换行符的区：windows：\n\r，mac：\r，Unix：\n。不同系统处理文件时要注意。</p></li><li><p>表达式里，有些特殊符号要在前面加\转义。比如：根据一个字符串生成一个正则，就需要转义正则里的全部特殊符号，不然直接生成正则是按转移后的字符生成的。</p></li><li><p>讲解两个正则：</p></li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机号</span></span><br><span class="line">/^((\+|<span class="number">00</span>)<span class="number">86</span>)?<span class="number">1</span>((<span class="number">3</span>[\d])|(<span class="number">4</span>[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>])|(<span class="number">5</span>[<span class="number">0</span>-<span class="number">3</span>,<span class="number">5</span>-<span class="number">9</span>])|(<span class="number">6</span>[<span class="number">5</span>-<span class="number">7</span>])|(<span class="number">7</span>[<span class="number">0</span>-<span class="number">8</span>])|(<span class="number">8</span>[\d])|(<span class="number">9</span>[<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>]))\d{<span class="number">8</span>}$/</span><br><span class="line"><span class="comment">// 密码强度校验：最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span></span><br><span class="line"><span class="regexp">/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span></span><br></pre></td></tr></tbody></table></figure><p>1.5 总结</p><ol><li>与：/ppp/，或：/p|p|p/，非：/[^ppp]/。</li><li>正则终究匹配的是字符或者位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端总结</title>
      <link href="/2021/09/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%80%E4%BA%9B/"/>
      <url>/2021/09/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%80%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="H5移动端开发总结"><a href="#H5移动端开发总结" class="headerlink" title="H5移动端开发总结"></a>H5移动端开发总结</h1><h4 id="移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等"><a href="#移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等" class="headerlink" title="移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等"></a>移动端一般会为了美观给html、body加统一样式，再用iScorll、betterScroll等</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>{</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这有个问题：body或者html依旧不是相对屏幕固定的，上下滑动会造成背景图位移等(Safari)，以下可解决：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>{</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是在移动端输入时，软键盘弹起解决页面被隐藏或者被顶起时，会有副作用。</p><h4 id="适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置"><a href="#适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置" class="headerlink" title="适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置"></a>适配一般选择动态计算根字体尺寸，rem为单位。当心有些安卓机型会根据系统设置字体大小修改webview的根字体大小，一般找原生端设置</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意这里是100倍，因为一般除不尽，多取几位缩小误差。所以应该有个css单位变量是htmlFontsize*1/100</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// spa完全可以放到body尾部</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> htmlFontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">375</span> * <span class="number">100</span> + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bodyFontSize = <span class="string">'16px'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> styleDom = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span></span><br><span class="line"><span class="javascript">        styleDom.innerHTML = <span class="string">'html{font-size:'</span> + htmlFontSize + <span class="string">'!important;}body{font-size:'</span> + bodyFontSize + <span class="string">'!important;}'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(styleDom)</span></span><br><span class="line"><span class="javascript">    })();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="禁止缩放和双击放大（包括Safari）"><a href="#禁止缩放和双击放大（包括Safari）" class="headerlink" title="禁止缩放和双击放大（包括Safari）"></a>禁止缩放和双击放大（包括Safari）</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastTouchEnd = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (event.touches.length &gt; <span class="number">1</span>) {</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">if</span> (now - lastTouchEnd &lt;= <span class="number">300</span>) {</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">    lastTouchEnd = now;</span><br><span class="line">}, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'gesturestart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    event.preventDefault();</span><br><span class="line">});</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'dblclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span><br><span class="line">    event.preventDefault();</span><br><span class="line">})</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="Safari滚动到动态列表时滑动出问题"><a href="#Safari滚动到动态列表时滑动出问题" class="headerlink" title="Safari滚动到动态列表时滑动出问题"></a>Safari滚动到动态列表时滑动出问题</h4><p>动态创建的列表高度没有预设高度，在动态创建列表（ajax等）后，浏览器没有计算好，导致滚动失败。解决办法：设置需要滚动的容器的(min-)height，撑起容器。  </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ts</title>
      <link href="/2021/09/27/%E5%85%B3%E4%BA%8Ets/"/>
      <url>/2021/09/27/%E5%85%B3%E4%BA%8Ets/</url>
      
        <content type="html"><![CDATA[<h1 id="1、TS初见"><a href="#1、TS初见" class="headerlink" title="1、TS初见"></a>1、TS初见</h1><h2 id="1-1、为什么要有-TypeScript"><a href="#1-1、为什么要有-TypeScript" class="headerlink" title="1.1、为什么要有 TypeScript"></a>1.1、为什么要有 TypeScript</h2><p>TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。</p><p>`TypeScript的初衷就是为了做类型检查，提早发现错误，所以「类型」是其最核心的特性。当然它只是给出你代码可能不会按预期执行的警告，比如你未按照声明的类型传参，你的代码还是可以运行的。这一点与强类型语言还是有本质的区别，强类型语言会直接导致编译不通过，因为TypeScript只是转译。跟JavaScript不同，TypeScript文件后缀使用 .ts扩展名。浏览器是不识别 .ts 文件，所以使用时必须提前把 TS 代码转换成 JavaScript 代码。这个转换过程被称为转译，编译和转译的微小差别在于：</p><p>编译是把源码转变成另一种语言<br>转译是把源码转变另一个相同抽象层级的语言</p><h2 id="1-2、前提准备"><a href="#1-2、前提准备" class="headerlink" title="1.2、前提准备"></a>1.2、前提准备</h2><ul><li>安装 node环境下安装 npm install -g typescript</li><li>手动编译 tsc  **.ts</li><li>vscode自动编译 tsc –init 在tsconfig.js中配置，在终端打开tsc监视即可</li><li>ts语法提示错误，不影响js的编译，因为js是弱类型语言（如类型注解不通过）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 类型注解 一种轻量级的为函数或变量添加约束</span><br><span class="line">(() =&gt; {</span><br><span class="line">    function showMsg(str:String) {</span><br><span class="line">        return str + '123214'</span><br><span class="line">    }</span><br><span class="line">    let str = "woshi"</span><br><span class="line">    console.log(showMsg(str));</span><br><span class="line">    </span><br><span class="line">})()</span><br><span class="line"></span><br><span class="line">// 接口演示 定义接口</span><br><span class="line">(() =&gt; {</span><br><span class="line">    interface Iperson{</span><br><span class="line">        fristName:string,</span><br><span class="line">        lastName:string</span><br><span class="line">    }</span><br><span class="line">    // 输出对象</span><br><span class="line">    function showFullName(person:Iperson) {</span><br><span class="line">        return person.fristName + person.lastName</span><br><span class="line">    }</span><br><span class="line">    // 定义对象</span><br><span class="line">    const person = {</span><br><span class="line">        fristName: 'dongfnag',</span><br><span class="line">        lastName: 'yuechu'</span><br><span class="line">    }</span><br><span class="line">    // 打印</span><br><span class="line">    console.log(showFullName(person))</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3、基础类型"><a href="#1-3、基础类型" class="headerlink" title="1.3、基础类型"></a>1.3、基础类型</h2><h3 id="1、布尔-数字-字符串"><a href="#1、布尔-数字-字符串" class="headerlink" title="1、布尔 数字 字符串"></a>1、布尔 数字 字符串</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a:boolean = true</span><br><span class="line">let b:number = 1010</span><br><span class="line">let c:string = '字符串'</span><br><span class="line"></span><br><span class="line">//字符串可与数字拼接 TS中变量一开始是什么类型就只能用这个类型，不允许混用</span><br></pre></td></tr></tbody></table></figure><h3 id="2、undefined-amp-null"><a href="#2、undefined-amp-null" class="headerlink" title="2、undefined &amp; null"></a>2、undefined &amp; null</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let und:undefined = undefined</span><br><span class="line">let nul:null = null</span><br><span class="line">// 给其他类型赋予</span><br><span class="line">let num:number = null</span><br><span class="line">let num:number = undefined</span><br><span class="line"></span><br><span class="line">// undefined和null 可以作为其他类型的子类型，可以将undef和null赋予其他类型（需关闭ts严格模式）</span><br></pre></td></tr></tbody></table></figure><h3 id="3、-数组和元组"><a href="#3、-数组和元组" class="headerlink" title="3、 数组和元组"></a>3、 数组和元组</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组定义方式1</span><br><span class="line">let arr:number[] = [10,20,30]</span><br><span class="line">数组定义方式2(泛型写法)</span><br><span class="line">let arr:Array&lt;number&gt; = [1,2,3]</span><br><span class="line"></span><br><span class="line">元组Tuple</span><br><span class="line">let arr:[string,boolean] = ['字符串', true]</span><br></pre></td></tr></tbody></table></figure><h3 id="4、Enum枚举-（ts补充）void"><a href="#4、Enum枚举-（ts补充）void" class="headerlink" title="4、Enum枚举 （ts补充）void"></a>4、Enum枚举 （ts补充）void</h3><p>使用枚举类型可以为一组赋值赋予友好的名字</p><p>void没有返回值的类型，打印undefined</p><h3 id="5、any-amp-unknown"><a href="#5、any-amp-unknown" class="headerlink" title="5、any &amp; unknown"></a>5、any &amp; unknown</h3><p><code>unknown</code>与<code>any</code>的最大区别是：</p><p>unknown是 top type(任何类型都是它的 subtype) , 而 <code>any</code> 既是 <code>top type</code>, 又是 <code>bottom type</code> (它是任何类型的 <code>subtype</code> ) , 这导致 <code>any</code> 基本上就是放弃了任何类型检查。因为<code>any</code>既是<code>top type</code>, 又是 <code>bottom type</code>，所以任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何类型。但<code>unknown</code> 只是 <code>top type</code>，任何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code>，因为只有它俩是<code>top type</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// any`会跳过类型检查器对值的检查，任何值都可以赋值给`any`类型，它通常被称为`top type</span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br><span class="line">// unknown与any一样，所有类型都可以分配给unknown:</span><br><span class="line">let notSure: unknown = 4;</span><br><span class="line">notSure = "maybe a string instead"; // OK</span><br><span class="line">notSure = false; // OK</span><br></pre></td></tr></tbody></table></figure><h3 id="6、object-amp-never"><a href="#6、object-amp-never" class="headerlink" title="6、object &amp; never"></a>6、object &amp; never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。</p><p>==<code>never</code>与其他类型的联合后，是没有<code>never</code>的==</p><p>值会永不存在的两种情况：</p><ol><li><p>如果一个函数执行时抛出了<strong>异常</strong>，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；</p></li><li><p>函数中执行无限循环的代码（<strong>死循环</strong>），使得程序永远无法运行到函数返回值那一步，永不存在返回。</p></li><li><p><code>never</code>类型同<code>null</code>和<code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型：</p></li><li><p>但是没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外），即使<code>any</code>也不可以赋值给<code>never</code>：</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    function getobj(obj:object):object {</span><br><span class="line">        console.log(obj)</span><br><span class="line">        return {</span><br><span class="line">            name: 'kakaxi'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    console.log(getobj({name: '213'}));</span><br></pre></td></tr></tbody></table></figure><h2 id="1-4、类型（联合-断言-交叉-推断）"><a href="#1-4、类型（联合-断言-交叉-推断）" class="headerlink" title="1.4、类型（联合 断言 交叉 推断）"></a>1.4、类型（联合 断言 交叉 推断）</h2><h3 id="1-1、联合类型"><a href="#1-1、联合类型" class="headerlink" title="1.1、联合类型"></a>1.1、联合类型</h3><p>联合类型表示取值可以为多种类型中的一种，使用 <code>|</code> 分隔每个类型。当任意属性使用联合类型且属性中存在可选属性时，需要联合<code>undefined</code>类型，否则编译报错，原因显而易见，因为可选属性可有可无</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: string | number</span><br><span class="line">a = 'ok',</span><br><span class="line">a = 11</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、类型断言"><a href="#1-2、类型断言" class="headerlink" title="1.2、类型断言"></a>1.2、类型断言</h3><p>类型断言好比其它语言里的类型转换，类型转换通常发生在你比<code>TS</code>更了解某个值的详细信息的时候。==(相当于告诉编译器，我知道我是什么类型，知道在干什莫，相信我！按我说的处理)==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 类型断言两种方法&lt;&gt; he as</span><br><span class="line">// 例：&lt;&gt;断定变量str为字符串类型</span><br><span class="line">(&lt;string&gt;str)</span><br><span class="line">// as方法</span><br><span class="line">(str as string)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、类型推断"><a href="#1-3、类型推断" class="headerlink" title="1.3、类型推断"></a>1.3、类型推断</h3><p>如果没有指定明确的类型，那么TS会按照类型推论的规则推断出一个类型，如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</p><h3 id="1-4、交叉类型"><a href="#1-4、交叉类型" class="headerlink" title="1.4、交叉类型"></a>1.4、交叉类型</h3><p>==交叉类型取的多个类型的并集，但是如果<code>key</code>相同但是类型不同，则该<code>key</code>为<code>never</code>类型==</p><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用<code>&amp;</code>定义交叉类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface A {</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">}</span><br><span class="line">interface B {</span><br><span class="line">  name: string,</span><br><span class="line">  gender: string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a: A &amp; B = { // OK</span><br><span class="line">    name: "兔兔",</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: "男"</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5、接口"><a href="#1-5、接口" class="headerlink" title="1.5、接口"></a>1.5、接口</h2><p>接口是对象状态（属性）和行为（方法）的抽象（描述）</p><p>（接口是一种类型 规范 规则 约束 能力）</p><p>可选属性readonly 只读属性？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Props { </span><br><span class="line">  readonly name: string; </span><br><span class="line">  age: number; </span><br><span class="line">  money?: number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于数组，<code>TS</code>还有<code>ReadonlyArray&lt;T&gt;</code>类型，此类型将数组的所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><p>==<code>readonly</code>声明的只读数组类型与<code>ReadonlyArray</code>声明的只读数组类型，二者等价==</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口继承接口使用关键字extends ，继承的本质是复制，抽出共同的代码，所以子接口拥有父接口的类型定义</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Shape {</span><br><span class="line">name: string</span><br><span class="line">}</span><br><span class="line">interface Square extends Shape {</span><br><span class="line">age: number</span><br><span class="line">}</span><br><span class="line">let square: Square = {name: '雷'， age: 18} </span><br><span class="line">接口可以多继承，大部分语言是不支持多继承的，原因是会引发混乱</span><br></pre></td></tr></tbody></table></figure><p><img src="image-20210907172322403.png" alt="image-20210907172322403"></p><h3 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h3><p>采用函数表达式接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc {</span><br><span class="line">(source: string, subString:string): boolean</span><br><span class="line">}</span><br><span class="line">// 左侧进行限制 限制参数为两个且必须为字符串类型，返回值必须为布尔型</span><br><span class="line">let mySearch: SearchFunc = function(source: string, subString:string) {</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt;-1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h2><h3 id="1-1、-函数声明-amp-函数表达式"><a href="#1-1、-函数声明-amp-函数表达式" class="headerlink" title="1.1、 函数声明 &amp; 函数表达式"></a>1.1、 函数声明 &amp; 函数表达式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">function sum(x:number, y:number) {</span><br><span class="line">return x + y</span><br><span class="line">}</span><br><span class="line">// 表达式</span><br><span class="line">let mysum:(x:number, y:number) =&gt; number = function(x;number, y:number):number {</span><br><span class="line">    return x + y</span><br><span class="line">}</span><br><span class="line">// 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。切忌与ES6的箭头函数混淆了。</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、函数中的this声明"><a href="#1-2、函数中的this声明" class="headerlink" title="1.2、函数中的this声明"></a>1.2、函数中的<code>this</code>声明</h3><p>ts会通过代码流分析出this是属于什么类型，，当然我们也可以明确的指定函数中的this是什么类型，==this类型变量必须放在参数的首位==</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj {</span><br><span class="line">    fn: (this: Obj, name: string) =&gt; void;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let obj: Obj = {</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let rab: Obj ={</span><br><span class="line">    fn(name: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj.fn("兔兔"); // OK</span><br><span class="line">obj.fn.call(rab, "兔兔"); // OK</span><br><span class="line">obj.fn.call(window, "兔兔"); // Error: this 应该为 Obj 类型</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、参数"><a href="#1-3、参数" class="headerlink" title="1.3、参数"></a>1.3、参数</h3><p><code>可选参数</code></p><p>​    参数后加问号（？）注：==可选参数后面不允许再出现必需参数==</p><p><code>参数默认值</code></p><p>​    在函数定义时，参数内直接赋值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = 'Cat') {</span><br><span class="line">    return firstName + ' ' + lastName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <code>剩余参数</code></p><p>同js，用 … 表示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) {</span><br><span class="line">    items.forEach(function(item) {</span><br><span class="line">        array.push(item);</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4、重载"><a href="#1-4、重载" class="headerlink" title="1.4、重载"></a>1.4、重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p><code>重载</code>的概念在学<code>JAVA</code>（<a href="https://link.juejin.cn/?target=https://www.runoob.com/java/java-override-overload.html"><code>JAVA中的重载</code></a>）的时候接触到的，<code>JS</code>是没有这个概念的，<code>TS</code>的重载感觉更应该称之为<code>函数签名重载</code>。因为最后函数实现的内部还是依赖判断类型来处理，前面的函数定义只是为了精确表达输入类型对应的输出类型。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string | void {</span><br><span class="line">    if (typeof x === 'number') {</span><br><span class="line">        return Number(x.toString().split('').reverse().join(''));</span><br><span class="line">    } else if (typeof x === 'string') {</span><br><span class="line">        return x.split('').reverse().join('');</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-7、-类"><a href="#1-7、-类" class="headerlink" title="1.7、 类"></a>1.7、 类</h2><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>public  属性修饰符默认为<code>public</code>公共的，即类的属性、方法可以在外部访问</li><li>private  与<code>public</code>相对，私有修饰符，即类的属性、方法不可以在外部访问</li><li>protected 修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在<strong>派生类</strong>中仍然可以访问。注意，这里是<strong>派生类中</strong>，而不是<strong>实例、子类实例</strong>。</li><li>readonly 只读属性修饰符 构造函数中可以对只读属性进行修改  <img src="image-20210910114715199.png" alt="image-20210910114715199"></li><li>发生继承关系后类与类的叫法<img src="image-20210909200925647.png" alt="image-20210909200925647"></li></ul><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>我们也可以在类的内部方法上对参数使用<code>public、private、protected</code>修饰符，它的作用是可以更方便地让我们在一个地方定义并初始化一个成员。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Animal {</span><br><span class="line">    constructor(public name: string, private age: number, protected sex: string) {}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="接口实现类"><a href="#接口实现类" class="headerlink" title="接口实现类"></a>接口实现类</h3><p><code>TypeScript</code> 也能够用接口来明确的强制一个类去符合某种契约。类去实现接口，这里使用关键字<code>implements</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 一个类可以实现多个接口</span><br><span class="line">interface Age {</span><br><span class="line">  age: number;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Title{</span><br><span class="line">  title: string;</span><br><span class="line">}</span><br><span class="line">class title implements Title, Age{</span><br><span class="line">  title: string = '兔兔';</span><br><span class="line">  age: number = 18;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用, 不允许被实例化。 不同于接口，抽象类可以包含成员的实现细节。 </p><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p><p><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department {</span><br><span class="line">    constructor(public name: string) {</span><br><span class="line">    }</span><br><span class="line">    printName(): void {</span><br><span class="line">        console.log('Department name: ' + this.name);</span><br><span class="line">    }</span><br><span class="line">    abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">}</span><br><span class="line">class AccountingDepartment extends Department {</span><br><span class="line">    constructor() {</span><br><span class="line">        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">    }</span><br><span class="line">    printMeeting(): void {</span><br><span class="line">        console.log('The Accounting Department meets each Monday at 10am.');</span><br><span class="line">    }</span><br><span class="line">    generateReports(): void {</span><br><span class="line">        console.log('Generating accounting reports...');</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let department: Department; // OK：允许创建一个对抽象类型的引用</span><br><span class="line">department = new Department(); // Error: 不能创建一个抽象类的实例</span><br><span class="line">department = new AccountingDepartment(); // OK：允许对一个抽象子类进行实例化和赋值</span><br><span class="line">department.printName(); // OK</span><br><span class="line">department.printMeeting(); // OK</span><br><span class="line">department.generateReports(); // Error: 方法在声明的抽象类中不存在</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-8、-泛型-lt-gt"><a href="#1-8、-泛型-lt-gt" class="headerlink" title="1.8、 泛型<>"></a>1.8、 泛型&lt;&gt;</h2><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王秋霞</title>
      <link href="/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/"/>
      <url>/2021/09/27/%E7%8E%8B%E7%A7%8B%E9%9C%9E/</url>
      
        <content type="html"><![CDATA[<p>大爷今年六十花甲，穿着皮裤叼着雪茄，精神抖擞红光满颊，钞票大把塞满皮夹，欲求一女共度晚霞，诚心征婚就在当下，愿那女子年纪不大，做事温柔不像三八。唠唠家常说说闲话</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
